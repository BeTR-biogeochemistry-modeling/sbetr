#!/usr/bin/env python
#in app_nameNlayer write three files
#CMakeLists.txt
#app_nameBGCReactionsType.F90
#app_namePlantSoilBGCType.F90

def MakeNlayer(sfarm_dir, app_name):
    print "create file "+sfarm_dir+'/'+app_name+'/'+app_name+'Nlayer'+"/CMakeLists.txt"
    fcmake=open(sfarm_dir+'/'+app_name+'/'+app_name+'Nlayer'+"/CMakeLists.txt","w")
    fcmake.write("set("+app_name.upper()+"NLAYER_SOURCES\n")
    fcmake.write("  "+app_name+"BGCReactionsType.F90\n")
    fcmake.write("  "+app_name+"PlantSoilBGCType.F90\n")
    fcmake.write(")\n")
    fcmake.write("\n")
    fcmake.write("include_directories(${CMAKE_BINARY_DIR}/src/betr/betr_util)\n")
    fcmake.write("include_directories(${CMAKE_BINARY_DIR}/src/betr/betr_math)\n")
    fcmake.write("include_directories(${CMAKE_BINARY_DIR}/src/betr/betr_bgc)\n")
    fcmake.write("include_directories(${CMAKE_BINARY_DIR}/src/betr/betr_grid)\n")
    fcmake.write("include_directories(${CMAKE_BINARY_DIR}/src/betr/betr_dtype)\n")
    fcmake.write("include_directories(${CMAKE_BINARY_DIR}/src/betr/betr_core)\n")
    fcmake.write("include_directories(${CMAKE_BINARY_DIR}/src/Applications/soil-farm/bgcfarm_util)\n")
    fcmake.write("include_directories(${CMAKE_BINARY_DIR}/src/Applications/soil-farm/"+app_name+"/"+app_name+"Para)\n")
    fcmake.write("include_directories(${CMAKE_BINARY_DIR}/src/Applications/soil-farm/"+app_name+"/"+app_name+"1layer)\n")
    fcmake.write("include(add_betr_library)\n")
    fcmake.write("add_betr_library("+app_name+"Nlayer ${"+app_name.upper()+"NLAYER_SOURCES})\n")

    fcmake.write("set(BETR_LIBRARIES "+app_name+"Nlayer;${BETR_LIBRARIES} PARENT_SCOPE)\n")
    fcmake.write("set(BETR_LIBRARIES "+app_name+"Nlayer;${BETR_LIBRARIES})\n")

#X#add_subdirectory(tests)

    fcmake.write('if (NOT CMAKE_INSTALL_PREFIX STREQUAL "INSTALL_DISABLED")\n')
    fcmake.write("  install(TARGETS "+app_name+"Nlayer DESTINATION lib)\n")
    fcmake.write("  file(GLOB HEADERS *.h)\n")
    fcmake.write("  install(FILES ${HEADERS} DESTINATION include/soil-farm/"+app_name+"/"+app_name+"Nlayer)\n")
    fcmake.write("endif()\n")
    fcmake.close()
#app_nameBGCReactionsType.F90
    print "create file "+sfarm_dir+'/'+app_name+'/'+app_name+'Nlayer/'+app_name+"BGCReactionsType.F90"
    ff90=open(sfarm_dir+'/'+app_name+'/'+app_name+'Nlayer/'+app_name+"BGCReactionsType.F90","w")
    ff90.write("module "+app_name+"BGCReactionsType\n")
    import datetime
    ff90.write('#include "bshr_assert.h"\n')
    ff90.write("!\n")
    ff90.write("! !DESCRIPTION:\n")
    ff90.write("! This is an example generated from AppMaker for use in betr\n")
    ff90.write("!\n")
    ff90.write("! HISTORY:\n")
    ff90.write("! Created by Jinyun Tang, "+datetime.date.today().strftime("%B %d, %Y")+"\n")
    ff90.write("! !USES:\n")
    ff90.write("  use bshr_log_mod             , only : errMsg => shr_log_errMsg\n")
    ff90.write("  use bshr_kind_mod            , only : r8 => shr_kind_r8\n")
    ff90.write("  use BeTR_decompMod           , only : bounds_type  => betr_bounds_type\n")
    ff90.write("  use BGCReactionsMod          , only : bgc_reaction_type\n")
    ff90.write("  use tracer_varcon            , only : bndcond_as_conc, bndcond_as_flux\n")
    ff90.write("  use BeTR_biogeophysInputType , only : betr_biogeophys_input_type\n")
    ff90.write("  use BetrStatusType           , only : betr_status_type\n")
    ff90.write("  use "+app_name+"ParaType            , only : "+app_name+"_para\n")
    ff90.write("  use "+app_name+"BGCIndexType        , only : "+app_name+"_bgc_index_type\n")
    ff90.write("  use "+app_name+"BGCType             , only : "+app_name+"_bgc_type\n")
    ff90.write("  use JarBgcForcType           , only : JarBGC_forc_type\n")
    ff90.write("implicit none\n")
    ff90.write("\n")
    ff90.write("  private\n")

    ff90.write("  character(len=*), parameter :: mod_filename = &\n")
    ff90.write("    __FILE__\n")

    ff90.write("  public :: "+app_name+"_bgc_reaction_type\n")

    ff90.write("  type, extends(bgc_reaction_type) :: &\n")
    ff90.write("    "+app_name+"_bgc_reaction_type\n")
    ff90.write("  private\n")
    ff90.write("    type("+app_name+"_bgc_type), pointer :: "+app_name+"_bgc(:,:)\n")
    ff90.write("    type(JarBGC_forc_type), pointer :: "+app_name+"_forc(:,:)\n")
    ff90.write("    type("+app_name+"_bgc_index_type) :: "+app_name+"_bgc_index\n")
    ff90.write("    logical :: use_c13\n")
    ff90.write("    logical :: use_c14\n")
    ff90.write("    logical :: nop_limit\n")
    ff90.write("    logical :: non_limit\n")
    ff90.write("    integer :: nactpft               ! number of active pfts\n")
    ff90.write("  contains\n")
    ff90.write("    procedure :: Init_betrbgc                          ! initialize betr bgc\n")
    ff90.write("    procedure :: set_boundary_conditions               ! set top/bottom boundary conditions for various tracers\n")
    ff90.write("    procedure :: calc_bgc_reaction                     ! doing bgc calculation\n")
    ff90.write("    procedure :: init_boundary_condition_type          ! initialize type of top boundary conditions\n")
    ff90.write("    procedure :: do_tracer_equilibration               ! do equilibrium tracer chemistry\n")
    ff90.write("    procedure :: InitCold                              ! do cold initialization\n")
    ff90.write("    procedure :: retrieve_biogeoflux           !\n")
    ff90.write("    procedure :: set_kinetics_par\n")
    ff90.write("    procedure :: retrieve_lnd2atm\n")
    ff90.write("    procedure :: readParams                   ! read in parameters\n")
    ff90.write("    procedure :: retrieve_biostates\n")
    ff90.write("    procedure :: debug_info\n")
    ff90.write("    procedure :: set_bgc_spinup\n")
    ff90.write("    procedure :: UpdateParas\n")
    ff90.write("    procedure :: init_iP_prof\n")
    ff90.write("    procedure, private :: set_tracer\n")
    ff90.write("    procedure, private :: InitAllocate\n")
    ff90.write("    procedure, private :: retrieve_output\n")
    ff90.write("    procedure, private :: set_bgc_forc\n")
    ff90.write("    procedure, private :: update_sorpphase_coeff\n")
    ff90.write("  end type "+app_name+"_bgc_reaction_type\n")
    ff90.write("\n")
    ff90.write("  interface "+app_name+"_bgc_reaction_type\n")
    ff90.write("    module procedure constructor\n")
    ff90.write("  end interface "+app_name+"_bgc_reaction_type\n")
    ff90.write("\n")
    ff90.write("contains\n")
    ff90.write("!-------------------------------------------------------------------------------\n")
    ff90.write("  type("+app_name+"_bgc_reaction_type) function constructor()\n")
    ff90.write("  !\n")
    ff90.write("  ! !DESCRIPTION:\n")
    ff90.write("  ! create an object of type "+app_name+"_bgc_reaction_type.\n")
    ff90.write("\n")
    ff90.write("  type("+app_name+"_bgc_reaction_type), allocatable :: bgc\n")
    ff90.write("  allocate(bgc)\n")
    ff90.write("  constructor = bgc\n")
    ff90.write("  end function constructor\n")
    ff90.write("!-------------------------------------------------------------------------------\n")
    ff90.write("  subroutine UpdateParas(this, bounds, lbj, ubj, bstatus)\n")
    ff90.write("  implicit none\n")
    ff90.write("  class("+app_name+"_bgc_reaction_type)         , intent(inout)    :: this\n")
    ff90.write("  type(bounds_type)                    , intent(in)    :: bounds\n")
    ff90.write("  integer                              , intent(in)    :: lbj, ubj        ! lower and upper bounds, make sure they are > 0\n")
    ff90.write("  type(betr_status_type)               , intent(out)   :: bstatus\n")
    ff90.write("  integer :: c, j\n")
    ff90.write("\n")
    ff90.write("  if (this%dummy_compiler_warning) continue\n")
    ff90.write("  call bstatus%reset()\n")
    ff90.write('  !do nothing\n')
    ff90.write("  end subroutine UpdateParas\n")
    ff90.write("!----------------------------------------------------------------------\n")
    ff90.write("  subroutine init_iP_prof(this, bounds, lbj, ubj, biophysforc, tracers, tracerstate_vars)\n")
    ff90.write("  !\n")
    ff90.write("  !DESCRIPTION\n")
    ff90.write("  ! set up initial inorganic P profile\n")
    ff90.write("  use tracer_varcon, only : patomw\n")
    ff90.write("  use tracerstatetype        , only : tracerstate_type\n")
    ff90.write("  use BeTRTracerType         , only : betrtracer_type\n")
    ff90.write("  implicit none\n")
    ff90.write("  ! !ARGUMENTS:\n")
    ff90.write("  class("+app_name+"_bgc_reaction_type)         , intent(inout)    :: this\n")
    ff90.write("  type(bounds_type)                        , intent(in) :: bounds\n")
    ff90.write("  integer                                  , intent(in) :: lbj, ubj\n")
    ff90.write("  type(betr_biogeophys_input_type)        , intent(inout) :: biophysforc\n")
    ff90.write("  type(BeTRtracer_type)                    , intent(inout) :: tracers\n")
    ff90.write("  type(tracerstate_type)                   , intent(inout) :: tracerstate_vars\n")
    ff90.write("\n")
    ff90.write("  if (this%dummy_compiler_warning) continue\n")
    ff90.write("  if (bounds%begc > 0) continue\n")
    ff90.write("\n")
    ff90.write("  end subroutine init_iP_prof\n")
    ff90.write("!----------------------------------------------------------------------\n")
    ff90.write("  subroutine set_kinetics_par(this, lbj, ubj, nactpft, plantNutkinetics, tracercoeff_vars)\n")
    ff90.write("  !\n")
    ff90.write("  !DESCRIPTION\n")
    ff90.write("  !set up kinetic parameters needed by the model\n")
    ff90.write("  use PlantNutKineticsMod, only : PlantNutKinetics_type\n")
    ff90.write("  use tracercoeffType          , only : tracercoeff_type\n")
    ff90.write("  ! !ARGUMENTS:\n")
    ff90.write("  class("+app_name+"_bgc_reaction_type)         , intent(inout)    :: this\n")
    ff90.write("  class(PlantNutKinetics_type), intent(in) :: plantNutkinetics\n")
    ff90.write("  type(tracercoeff_type), intent(inout) :: tracercoeff_vars\n")
    ff90.write("  integer, intent(in) :: lbj, ubj\n")
    ff90.write("  integer, intent(in) :: nactpft\n")
    ff90.write("  integer :: c_l, p, j\n")
    ff90.write("  !in the following, only one column is assumed for the bgc\n")
    ff90.write("  c_l = 1\n")
    ff90.write("  this%nactpft = nactpft\n")
    ff90.write("  do j = lbj, ubj\n")
    ff90.write("    !effective p competing decomposers\n")
    ff90.write("    this%"+app_name+"_forc(c_l,j)%Msurf_OM  = plantNutkinetics%minsurf_dom_compet_vr_col(c_l,j)\n")
    ff90.write("    this%"+app_name+"_forc(c_l,j)%KM_OM_ref = plantNutkinetics%km_minsurf_dom_vr_col(c_l,j)\n")
    ff90.write("  enddo\n")
    ff90.write("  end subroutine set_kinetics_par\n")
    ff90.write("!-------------------------------------------------------------------------------\n")
    ff90.write("  subroutine init_boundary_condition_type(this, bounds, betrtracer_vars, tracerboundarycond_vars )\n")
    ff90.write("  !\n")
    ff90.write("  ! !DESCRIPTION:\n")
    ff90.write("  ! initialize boundary condition types\n")
    ff90.write("  !\n")
    ff90.write("  ! !USES:\n")
    ff90.write("  use BeTRTracerType        , only : betrtracer_type\n")
    ff90.write("  use TracerBoundaryCondType, only : tracerboundarycond_type\n")
    ff90.write("  use tracer_varcon         , only : bndcond_as_conc, bndcond_as_flux\n")
    ff90.write("  use BeTRTracerType        , only : betrtracer_type\n")
    ff90.write("  ! !ARGUMENTS:\n")
    ff90.write("  class("+app_name+"_bgc_reaction_type), intent(inout) :: this\n")
    ff90.write("  type(BeTRtracer_type),             intent(in) :: betrtracer_vars\n")
    ff90.write("  type(bounds_type),                 intent(in) :: bounds\n")
    ff90.write("  type(tracerboundarycond_type),     intent(in) :: tracerboundarycond_vars\n")
    ff90.write("  ! !LOCAL VARIABLES:\n")
    ff90.write("  ! remove compiler warnings for unused dummy args\n")
    ff90.write("  if (this%dummy_compiler_warning) continue\n")
    ff90.write("  if (bounds%begc > 0) continue\n")
    ff90.write("  if (len(betrtracer_vars%betr_simname) > 0) continue\n")
    ff90.write("  tracerboundarycond_vars%topbc_type(:) = bndcond_as_conc\n")
    ff90.write("  !when bottom BC is not given, it is specified as constant flux\n")
    ff90.write("  !X!tracerboundarycond_vars%botbc_type(:) = bndcond_as_flux\n")
    ff90.write("  end subroutine init_boundary_condition_type\n")
    ff90.write("!-------------------------------------------------------------------------------\n")
    ff90.write("subroutine set_bgc_spinup(this, bounds, lbj, ubj, biophysforc, &\n")
    ff90.write("  tracers, tracerstate_vars)\n")
    ff90.write("  use tracerstatetype        , only : tracerstate_type\n")
    ff90.write("  use BeTRTracerType         , only : betrtracer_type\n")
    ff90.write("  use BeTR_decompMod         , only : betr_bounds_type\n")
    ff90.write("\n")
    ff90.write("  implicit none\n")
    ff90.write("  class("+app_name+"_bgc_reaction_type), intent(inout)    :: this\n")
    ff90.write("  type(betr_bounds_type)                  , intent(in) :: bounds\n")
    ff90.write("  integer                                 , intent(in) :: lbj, ubj\n")
    ff90.write("  type(betr_biogeophys_input_type)        , intent(inout) :: biophysforc\n")
    ff90.write("  type(BeTRtracer_type)                   , intent(inout) :: tracers\n")
    ff90.write("  type(tracerstate_type)                  , intent(inout) :: tracerstate_vars\n")
    ff90.write("\n")
    ff90.write("  if (this%dummy_compiler_warning) continue\n")
    ff90.write("  if (bounds%begc > 0) continue\n")
    ff90.write("  end subroutine set_bgc_spinup\n")
    ff90.write("!-------------------------------------------------------------------------------\n")
    ff90.write("  subroutine InitAllocate(this, bounds, lbj, ubj, bstatus)\n")
    ff90.write("  !\n")
    ff90.write("  !!DESCRIPTION\n")
    ff90.write("  !allocate memory\n")
    ff90.write("  use betr_varcon                      , only : betr_maxpatch_pft\n")
    ff90.write("  implicit none\n")
    ff90.write("  class("+app_name+"_bgc_reaction_type), intent(inout)    :: this\n")
    ff90.write("  type(betr_status_type)           , intent(out)   :: bstatus\n")
    ff90.write("  type(bounds_type)                , intent(in)    :: bounds\n")
    ff90.write("  integer                          , intent(in)    :: lbj, ubj\n")
    ff90.write("  integer :: j, c\n")
    ff90.write("  logical :: batch_mode\n")
    ff90.write("  batch_mode =.false.\n")
    ff90.write("  this%nactpft = 0\n")
    ff90.write("\n")
    ff90.write("  call this%"+app_name+"_bgc_index%Init("+app_name+"_para%use_c13, "+app_name+"_para%use_c14, &\n")
    ff90.write("  "+app_name+"_para%non_limit, "+app_name+"_para%nop_limit, betr_maxpatch_pft)\n")
    ff90.write("  if(bstatus%check_status())return\n")
    ff90.write("  !create the models\n")
    ff90.write("  allocate(this%"+app_name+"_bgc(bounds%begc:bounds%endc,lbj:ubj))\n")
    ff90.write("  !create model specific forcing data structure\n")
    ff90.write("  allocate(this%"+app_name+"_forc(bounds%begc:bounds%endc,lbj:ubj))\n")
    ff90.write("  !initialize\n")
    ff90.write("  do j = lbj, ubj\n")
    ff90.write("    do c = bounds%begc, bounds%endc\n")
    ff90.write("      call this%"+app_name+"_bgc(c,j)%Init("+app_name+"_para, batch_mode, bstatus)\n")
    ff90.write("      if(bstatus%check_status())return\n")
    ff90.write("      call this%"+app_name+"_forc(c,j)%Init(this%"+app_name+"_bgc_index%nstvars)\n")
    ff90.write("    enddo\n")
    ff90.write("  enddo\n")
    ff90.write("  end subroutine InitAllocate\n")
    ff90.write("!-------------------------------------------------------------------------------\n")
    ff90.write("  subroutine Init_betrbgc(this, bounds, lbj, ubj, betrtracer_vars, namelist_buffer, bstatus)\n")
    ff90.write("!\n")
    ff90.write("! DESCRIPTION:\n")
    ff90.write("! initialize the betrbgc\n")
    ff90.write("!\n")
    ff90.write("! !USES:\n")
    ff90.write("  use BeTRTracerType , only : betrtracer_type\n")
    ff90.write("  use BetrStatusType , only : betr_status_type\n")
    ff90.write("  use gbetrType      , only : gbetr_type\n")
    ff90.write("  implicit none\n")
    ff90.write("  ! !ARGUMENTS:\n")
    ff90.write("  class("+app_name+"_bgc_reaction_type), intent(inout)    :: this\n")
    ff90.write("  type(bounds_type)                , intent(in)    :: bounds\n")
    ff90.write("  integer                          , intent(in)    :: lbj, ubj\n")
    ff90.write("  type(BeTRtracer_type )           , intent(inout) :: betrtracer_vars\n")
    ff90.write("  character(len=*)                 , intent(in)    :: namelist_buffer\n")
    ff90.write("  type(betr_status_type)           , intent(out)   :: bstatus\n")
    ff90.write("  !LOCAL VARIABLES\n")
    ff90.write("  character(len=*), parameter                      :: subname ='Init_betrbgc'\n")
    ff90.write("  call bstatus%reset()\n")
    ff90.write("  ! remove compiler warnings for unused dummy args\n")
    ff90.write("  if (this%dummy_compiler_warning)           continue\n")
    ff90.write("  if (bounds%begc > 0)                       continue\n")
    ff90.write("  if (ubj > lbj)                             continue\n")
    ff90.write("  if (len(betrtracer_vars%betr_simname) > 0) continue\n")
    ff90.write("  call this%InitAllocate(bounds, lbj, ubj, bstatus)\n")
    ff90.write("  if(bstatus%check_status())return\n")
    ff90.write("  this%use_c13 = "+app_name+"_para%use_c13\n")
    ff90.write("  this%use_c14 = "+app_name+"_para%use_c14\n")
    ff90.write("  this%nop_limit="+app_name+"_para%nop_limit\n")
    ff90.write("  this%non_limit="+app_name+"_para%non_limit\n")
    ff90.write("  call this%set_tracer(betrtracer_vars, bstatus)\n")
    ff90.write("  end subroutine Init_betrbgc\n")
    ff90.write("!-------------------------------------------------------------------------------\n")
    ff90.write("  subroutine set_tracer(this, betrtracer_vars, bstatus)\n")
    ff90.write("  use BeTRTracerType  , only : betrtracer_type\n")
    ff90.write("  use MathfuncMod     , only : addone\n")
    ff90.write("  implicit none\n")
    ff90.write("  class("+app_name+"_bgc_reaction_type), intent(inout)    :: this\n")
    ff90.write("  type(BeTRtracer_type )           , intent(inout) :: betrtracer_vars\n")
    ff90.write("  type(betr_status_type)           , intent(out)   :: bstatus\n")
    ff90.write("  !LOCAL VARIABLES\n")
    ff90.write("  integer :: itemp_gwm\n")
    ff90.write("  integer :: itemp_g\n")
    ff90.write("  integer :: itemp_s\n")
    ff90.write("  integer :: itemp_gwm_grp\n")
    ff90.write("  integer :: dum, itemp\n")
    ff90.write("  integer :: itemp_grp, itemp_v, itemp_vgrp, itemp_trc, itemp_ads, itemp_ads_grp\n")
    ff90.write("  integer :: litr_cnt, wood_cnt, Bm_cnt, trcid, itemp_mem, ngroupmems\n")
    ff90.write("\n")
    ff90.write("  associate(                           &\n")
    ff90.write("    nelm    => this%"+app_name+"_bgc_index%nelms,   &\n")
    ff90.write("    c_loc   => this%"+app_name+"_bgc_index%c_loc,   &\n")
    ff90.write("    c13_loc => this%"+app_name+"_bgc_index%c13_loc, &\n")
    ff90.write("    c14_loc => this%"+app_name+"_bgc_index%c14_loc, &\n")
    ff90.write("    e_loc   => this%"+app_name+"_bgc_index%e_loc    &\n")
    ff90.write("  )\n")
    ff90.write("  itemp_gwm     = 0\n")
    ff90.write("  itemp_g       = 0\n")
    ff90.write("  itemp_s       = 0\n")
    ff90.write("  itemp_gwm_grp = 0\n")
    ff90.write("  itemp_ads_grp =0!counter for sorptive groups\n")
    ff90.write("  itemp_ads=0     !counter for sorptive tracers\n")
    ff90.write("  !volatile tracers\n")
    ff90.write("  itemp = 0; itemp_trc=0\n")
    ff90.write("  call betrtracer_vars%add_tracer_group(trc_grp_cnt=addone(itemp), mem = 1, &\n")
    ff90.write("    trc_cnt=itemp_trc, trc_grp=betrtracer_vars%id_trc_n2, &\n")
    ff90.write("    trc_grp_beg=betrtracer_vars%id_trc_beg_n2,&\n")
    ff90.write("    trc_grp_end=betrtracer_vars%id_trc_end_n2, is_trc_gw=.true., is_trc_volatile = .true.)\n")
    ff90.write("\n")
    ff90.write("  call betrtracer_vars%add_tracer_group(trc_grp_cnt=addone(itemp), mem = 1, &\n")
    ff90.write("    trc_cnt=itemp_trc, trc_grp=betrtracer_vars%id_trc_o2, &\n")
    ff90.write("    trc_grp_beg=betrtracer_vars%id_trc_beg_o2, &\n")
    ff90.write("    trc_grp_end=betrtracer_vars%id_trc_end_o2, &\n")
    ff90.write("    is_trc_gw=.true., is_trc_volatile = .true.)\n")
    ff90.write("\n")
    ff90.write("  call betrtracer_vars%add_tracer_group(trc_grp_cnt=addone(itemp), mem = 1, &\n")
    ff90.write("    trc_cnt=itemp_trc, trc_grp=betrtracer_vars%id_trc_ar,&\n")
    ff90.write("    trc_grp_beg= betrtracer_vars%id_trc_beg_ar, &\n")
    ff90.write("    trc_grp_end= betrtracer_vars%id_trc_end_ar, &\n")
    ff90.write("    is_trc_gw=.true., is_trc_volatile = .true.)\n")
    ff90.write("\n")
    ff90.write("  call betrtracer_vars%add_tracer_group(trc_grp_cnt=addone(itemp), mem = 1, &\n")
    ff90.write("    trc_cnt=itemp_trc, trc_grp=betrtracer_vars%id_trc_co2x, &\n")
    ff90.write("    trc_grp_beg=betrtracer_vars%id_trc_beg_co2x, &\n")
    ff90.write("    trc_grp_end=betrtracer_vars%id_trc_end_co2x, &\n")
    ff90.write("    is_trc_gw=.true., is_trc_volatile = .true.)\n")
    ff90.write("\n")
    ff90.write("  if(this%use_c13)then\n")
    ff90.write("    call betrtracer_vars%add_tracer_group(trc_grp_cnt=addone(itemp), mem = 1, &\n")
    ff90.write("      trc_cnt=itemp_trc, trc_grp=betrtracer_vars%id_trc_c13_co2x, &\n")
    ff90.write("      trc_grp_beg=betrtracer_vars%id_trc_beg_c13_co2x, &\n")
    ff90.write("      trc_grp_end=betrtracer_vars%id_trc_end_c13_co2x, &\n")
    ff90.write("      is_trc_gw=.true., is_trc_volatile = .true.)\n")
    ff90.write("  endif\n")
    ff90.write("  if(this%use_c14)then\n")
    ff90.write("    call betrtracer_vars%add_tracer_group(trc_grp_cnt=addone(itemp), mem = 1, &\n")
    ff90.write("      trc_cnt=itemp_trc, trc_grp=betrtracer_vars%id_trc_c14_co2x, &\n")
    ff90.write("      trc_grp_beg=betrtracer_vars%id_trc_beg_c14_co2x, &\n")
    ff90.write("      trc_grp_end=betrtracer_vars%id_trc_end_c14_co2x, &\n")
    ff90.write("      is_trc_gw=.true., is_trc_volatile = .true.)\n")
    ff90.write("  endif\n")
    ff90.write("\n")
    ff90.write("  call betrtracer_vars%add_tracer_group(trc_grp_cnt=addone(itemp), mem = 1, &\n")
    ff90.write("    trc_cnt=itemp_trc, trc_grp= betrtracer_vars%id_trc_ch4, &\n")
    ff90.write("    trc_grp_beg= betrtracer_vars%id_trc_beg_ch4, &\n")
    ff90.write("    trc_grp_end= betrtracer_vars%id_trc_end_ch4, &\n")
    ff90.write("    is_trc_gw=.true., is_trc_volatile = .true.)\n")
    ff90.write("\n")
    ff90.write("  ngroupmems=nelm+1  !dom, element + energy\n")
    ff90.write("  call betrtracer_vars%add_tracer_group(trc_grp_cnt=addone(itemp), mem = ngroupmems, &\n")
    ff90.write("    trc_cnt=itemp_trc, trc_grp=betrtracer_vars%id_trc_dom, &\n")
    ff90.write("    trc_grp_beg=betrtracer_vars%id_trc_beg_dom, &\n")
    ff90.write("    trc_grp_end=betrtracer_vars%id_trc_end_dom, &\n")
    ff90.write("    is_trc_gw=.true., is_trc_volatile = .false.)\n")
    ff90.write("\n")
    ff90.write("  ngroupmems=nelm+1  !pom, element + energy\n")
    ff90.write("  call betrtracer_vars%add_tracer_group(trc_grp_cnt=addone(itemp), mem = ngroupmems, &\n")
    ff90.write("    trc_cnt=itemp_trc, trc_grp=betrtracer_vars%id_trc_pom, &\n")
    ff90.write("    trc_grp_beg=betrtracer_vars%id_trc_beg_pom, &\n")
    ff90.write("    trc_grp_end=betrtracer_vars%id_trc_end_pom, &\n")
    ff90.write("    is_trc_passive=.true.)\n")
    ff90.write('\n')
    ff90.write("  !three litter groups\n")
    ff90.write("  ngroupmems = 3*nelm\n")
    ff90.write("  call betrtracer_vars%add_tracer_group(trc_grp_cnt=addone(itemp), mem = ngroupmems, &\n")
    ff90.write("    trc_cnt=itemp_trc, trc_grp=betrtracer_vars%id_trc_litr, &\n")
    ff90.write("    trc_grp_beg=betrtracer_vars%id_trc_beg_litr, &\n")
    ff90.write("    trc_grp_end=betrtracer_vars%id_trc_end_litr, &\n")
    ff90.write("    is_trc_passive=.true.)\n")
    ff90.write("\n")
    ff90.write("  ngroupmems = nelm\n")
    ff90.write("  call betrtracer_vars%add_tracer_group(trc_grp_cnt=addone(itemp), &\n")
    ff90.write("    is_trc_passive=.true., mem = ngroupmems, &\n")
    ff90.write("    trc_cnt=itemp_trc, trc_grp=betrtracer_vars%id_trc_wood, &\n")
    ff90.write("    trc_grp_beg=betrtracer_vars%id_trc_beg_wood, &\n")
    ff90.write("    trc_grp_end=betrtracer_vars%id_trc_end_wood)\n")
    ff90.write("\n")
    ff90.write("  ngroupmems = 2*nelm\n")
    ff90.write("  call betrtracer_vars%add_tracer_group(trc_grp_cnt=addone(itemp),mem = ngroupmems, &\n")
    ff90.write("    trc_cnt=itemp_trc, trc_grp=betrtracer_vars%id_trc_Bm, &\n")
    ff90.write("    trc_grp_beg=betrtracer_vars%id_trc_beg_Bm, &\n")
    ff90.write("    trc_grp_end=betrtracer_vars%id_trc_end_Bm, &\n")
    ff90.write("    is_trc_passive=.true.)\n")
    ff90.write("\n")
    ff90.write("  betrtracer_vars%nmem_max               = nelm*3\n")
    ff90.write("\n")
    ff90.write("  call betrtracer_vars%Init()\n")
    ff90.write("\n")
    ff90.write("  itemp_grp = 0    !group id\n")
    ff90.write("  itemp_v = 0      !volatile id\n")
    ff90.write("  itemp_vgrp = 0   !volatile group\n")
    ff90.write("\n")
    ff90.write("  call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = betrtracer_vars%id_trc_n2, trc_name='N2'  ,      &\n")
    ff90.write("     is_trc_mobile=.true., is_trc_advective = .true., trc_group_id = addone(itemp_grp),   &\n")
    ff90.write("     trc_group_mem= 1,  is_trc_volatile=.true., trc_volatile_id = addone(itemp_v)     ,   &\n")
    ff90.write("     trc_volatile_group_id = addone(itemp_vgrp))\n")
    ff90.write("  if(bstatus%check_status())return\n")
    ff90.write("\n")
    ff90.write("  call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = betrtracer_vars%id_trc_o2, trc_name='O2'  ,      &\n")
    ff90.write("     is_trc_mobile=.true., is_trc_advective = .true., trc_group_id = addone(itemp_grp),   &\n")
    ff90.write("     trc_group_mem = 1, is_trc_volatile=.true., trc_volatile_id = addone(itemp_v)     ,   &\n")
    ff90.write("     trc_volatile_group_id = addone(itemp_vgrp))\n")
    ff90.write("  if(bstatus%check_status())return\n")
    ff90.write("\n")
    ff90.write("  call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = betrtracer_vars%id_trc_ar, trc_name='AR'  ,      &\n")
    ff90.write("     is_trc_mobile=.true., is_trc_advective = .true., trc_group_id = addone(itemp_grp),   &\n")
    ff90.write("     trc_group_mem = 1, is_trc_volatile=.true., trc_volatile_id = addone(itemp_v)     ,   &\n")
    ff90.write("     trc_volatile_group_id = addone(itemp_vgrp))\n")
    ff90.write("  if(bstatus%check_status())return\n")
    ff90.write("\n")
    ff90.write("  call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = betrtracer_vars%id_trc_co2x, trc_name='CO2x',    &\n")
    ff90.write("     is_trc_mobile=.true., is_trc_advective = .true., trc_group_id = addone(itemp_grp)  , &\n")
    ff90.write("     trc_group_mem = 1, is_trc_volatile=.true., trc_volatile_id = addone(itemp_v)       , &\n")
    ff90.write("     trc_volatile_group_id = addone(itemp_vgrp))\n")
    ff90.write("  if(bstatus%check_status())return\n")
    ff90.write("\n")
    ff90.write("  call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = betrtracer_vars%id_trc_ch4, trc_name='CH4',      &\n")
    ff90.write("     is_trc_mobile=.true., is_trc_advective = .true., trc_group_id = addone(itemp_grp),   &\n")
    ff90.write("     trc_group_mem = 1, is_trc_volatile=.true., trc_volatile_id = addone(itemp_v)     ,   &\n")
    ff90.write("     trc_volatile_group_id = addone(itemp_vgrp))\n")
    ff90.write("  if(bstatus%check_status())return\n")
    ff90.write("\n")
    ff90.write("  if(this%use_c13)then\n")
    ff90.write("    call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = betrtracer_vars%id_trc_c13_co2x, &\n")
    ff90.write("      trc_name='13CO2x', is_trc_mobile=.true., is_trc_advective = .true., &\n")
    ff90.write("      trc_group_id = betrtracer_vars%id_trc_c13_co2x, trc_group_mem = 1, is_trc_volatile=.true., &\n")
    ff90.write("      trc_volatile_id = addone(itemp_v),  trc_volatile_group_id = addone(itemp_vgrp), &\n")
    ff90.write("      trc_family_name='CO2x')\n")
    ff90.write("    if(bstatus%check_status())return\n")
    ff90.write("  endif\n")
    ff90.write("\n")
    ff90.write("  if(this%use_c14)then\n")
    ff90.write("    call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = betrtracer_vars%id_trc_c14_co2x, &\n")
    ff90.write("      trc_name='14CO2x', is_trc_mobile=.true., is_trc_advective = .true., &\n")
    ff90.write("      trc_group_id = betrtracer_vars%id_trc_c14_co2x, trc_group_mem = 1, is_trc_volatile=.true., &\n")
    ff90.write("      trc_volatile_id = addone(itemp_v),  trc_volatile_group_id = addone(itemp_vgrp), &\n")
    ff90.write("      trc_family_name='CO2x')\n")
    ff90.write("    if(bstatus%check_status())return\n")
    ff90.write("  endif\n")
    ff90.write("\n")
    ff90.write("  itemp_mem=0\n")
    ff90.write("  litr_cnt = 0\n")
    ff90.write("  trcid = betrtracer_vars%id_trc_beg_litr+litr_cnt*nelm+c_loc-1\n")
    ff90.write("  call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = trcid, trc_name='LIT1C' ,    &\n")
    ff90.write("     is_trc_mobile=.true., is_trc_advective = .false., &\n")
    ff90.write("     trc_group_id = betrtracer_vars%id_trc_litr, trc_group_mem= addone(itemp_mem), &\n")
    ff90.write("     trc_family_name='LIT1')\n")
    ff90.write("  if(bstatus%check_status())return\n")
    ff90.write("\n")
    ff90.write("  if(this%use_c13)then\n")
    ff90.write("    trcid = betrtracer_vars%id_trc_beg_litr+litr_cnt*nelm+c13_loc-1\n")
    ff90.write("    call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = trcid, trc_name='LIT1C_C13' ,    &\n")
    ff90.write("      is_trc_mobile=.true., is_trc_advective = .false., &\n")
    ff90.write("      trc_group_id = betrtracer_vars%id_trc_litr, trc_group_mem= addone(itemp_mem), &\n")
    ff90.write("      trc_family_name='LIT1')\n")
    ff90.write("    if(bstatus%check_status())return\n")
    ff90.write("  endif\n")
    ff90.write("\n")
    ff90.write("  if(this%use_c14)then\n")
    ff90.write("    trcid = betrtracer_vars%id_trc_beg_litr+litr_cnt*nelm+c14_loc-1\n")
    ff90.write("    call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = trcid, trc_name='LIT1C_C14' ,    &\n")
    ff90.write("      is_trc_mobile=.true., is_trc_advective = .false., &\n")
    ff90.write("      trc_group_id = betrtracer_vars%id_trc_litr, trc_group_mem= addone(itemp_mem), &\n")
    ff90.write("      trc_family_name='LIT1')\n")
    ff90.write("    if(bstatus%check_status())return\n")
    ff90.write("  endif\n")
    ff90.write("  litr_cnt = litr_cnt + 1\n")
    ff90.write("\n")
    ff90.write("  trcid = betrtracer_vars%id_trc_beg_litr+litr_cnt*nelm+c_loc-1\n")
    ff90.write("  call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = trcid, trc_name='LIT2C'  ,    &\n")
    ff90.write("     is_trc_mobile=.true., is_trc_advective = .false., &\n")
    ff90.write("     trc_group_id = betrtracer_vars%id_trc_litr, trc_group_mem= addone(itemp_mem), &\n")
    ff90.write("     trc_family_name='LIT2')\n")
    ff90.write("  if(bstatus%check_status())return\n")
    ff90.write("\n")
    ff90.write("  if(this%use_c13)then\n")
    ff90.write("    trcid = betrtracer_vars%id_trc_beg_litr+litr_cnt*nelm+c13_loc-1\n")
    ff90.write("    call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = trcid, trc_name='LIT2C_C13' ,    &\n")
    ff90.write("      is_trc_mobile=.true., is_trc_advective = .false., &\n")
    ff90.write("      trc_group_id = betrtracer_vars%id_trc_litr, trc_group_mem= addone(itemp_mem), &\n")
    ff90.write("      trc_family_name='LIT2')\n")
    ff90.write("    if(bstatus%check_status())return\n")
    ff90.write("  endif\n")
    ff90.write("\n")
    ff90.write("  if(this%use_c14)then\n")
    ff90.write("    trcid = betrtracer_vars%id_trc_beg_litr+litr_cnt*nelm+c14_loc-1\n")
    ff90.write("    call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = trcid, trc_name='LIT2C_C14' ,    &\n")
    ff90.write("      is_trc_mobile=.true., is_trc_advective = .false., &\n")
    ff90.write("      trc_group_id = betrtracer_vars%id_trc_litr, trc_group_mem= addone(itemp_mem), &\n")
    ff90.write("      trc_family_name='LIT2')\n")
    ff90.write("    if(bstatus%check_status())return\n")
    ff90.write("  endif\n")
    ff90.write("  litr_cnt=litr_cnt+1\n")
    ff90.write("\n")
    ff90.write("  trcid = betrtracer_vars%id_trc_beg_litr+litr_cnt*nelm+c_loc-1\n")
    ff90.write("  call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = trcid, trc_name='LIT3C' ,    &\n")
    ff90.write("     is_trc_mobile=.true., is_trc_advective = .false., &\n")
    ff90.write("     trc_group_id = betrtracer_vars%id_trc_litr, trc_group_mem= addone(itemp_mem), &\n")
    ff90.write("     trc_family_name='LIT3')\n")
    ff90.write("  if(bstatus%check_status())return\n")
    ff90.write("\n")
    ff90.write("  if(this%use_c13)then\n")
    ff90.write("    trcid = betrtracer_vars%id_trc_beg_litr+litr_cnt*nelm+c13_loc-1\n")
    ff90.write("    call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = trcid, trc_name='LIT3C_C13' ,    &\n")
    ff90.write("      is_trc_mobile=.true., is_trc_advective = .false., &\n")
    ff90.write("      trc_group_id = betrtracer_vars%id_trc_litr, trc_group_mem= addone(itemp_mem), &\n")
    ff90.write("      trc_family_name='LIT3')\n")
    ff90.write("    if(bstatus%check_status())return\n")
    ff90.write("  endif\n")
    ff90.write("  if(this%use_c14)then\n")
    ff90.write("    trcid = betrtracer_vars%id_trc_beg_litr+litr_cnt*nelm+c14_loc-1\n")
    ff90.write("    call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = trcid, trc_name='LIT3C_C14' ,    &\n")
    ff90.write("      is_trc_mobile=.true., is_trc_advective = .false., &\n")
    ff90.write("      trc_group_id = betrtracer_vars%id_trc_litr, trc_group_mem= addone(itemp_mem), &\n")
    ff90.write("      trc_family_name='LIT3')\n")
    ff90.write("    if(bstatus%check_status())return\n")
    ff90.write("  endif\n")
    ff90.write("\n")
    ff90.write("  wood_cnt=0\n")
    ff90.write("  itemp_mem=0\n")
    ff90.write("  !coarse root woody components, equivalent to default cwd\n")
    ff90.write("  trcid = betrtracer_vars%id_trc_beg_wood+wood_cnt*nelm+c_loc-1\n")
    ff90.write("  call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = trcid, trc_name='CWDC' ,    &\n")
    ff90.write("    is_trc_mobile=.false., is_trc_advective = .false., &\n")
    ff90.write("    trc_group_id = betrtracer_vars%id_trc_wood, trc_group_mem= addone(itemp_mem), &\n")
    ff90.write("    trc_family_name='CWD')\n")
    ff90.write("  if(bstatus%check_status())return\n")
    ff90.write("\n")
    ff90.write("  if(this%use_c13)then\n")
    ff90.write("    trcid = betrtracer_vars%id_trc_beg_wood+wood_cnt*nelm+c13_loc-1\n")
    ff90.write("    call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = trcid, trc_name='CWDC_C13' ,    &\n")
    ff90.write("      is_trc_mobile=.false., is_trc_advective = .false., &\n")
    ff90.write("      trc_group_id = betrtracer_vars%id_trc_wood, trc_group_mem= addone(itemp_mem), &\n")
    ff90.write("      trc_family_name='CWD')\n")
    ff90.write("    if(bstatus%check_status())return\n")
    ff90.write("  endif\n")
    ff90.write("\n")
    ff90.write("  if(this%use_c14)then\n")
    ff90.write("    trcid = betrtracer_vars%id_trc_beg_wood+wood_cnt*nelm+c14_loc-1\n")
    ff90.write("    call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = trcid, trc_name='CWDC_C14' ,    &\n")
    ff90.write("      is_trc_mobile=.false., is_trc_advective = .false., &\n")
    ff90.write("      trc_group_id = betrtracer_vars%id_trc_wood, trc_group_mem= addone(itemp_mem), &\n")
    ff90.write("      trc_family_name='CWD')\n")
    ff90.write("    if(bstatus%check_status())return\n")
    ff90.write("  endif\n")
    ff90.write("\n")
    ff90.write("  Bm_cnt=0;itemp_mem=0\n")
    ff90.write("  trcid = betrtracer_vars%id_trc_beg_Bm+Bm_cnt*nelm+c_loc-1\n")
    ff90.write("  call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = trcid, trc_name='MB_live', &\n")
    ff90.write("     is_trc_mobile=.true., is_trc_advective = .false., &\n")
    ff90.write("     trc_group_id = betrtracer_vars%id_trc_Bm, trc_group_mem = addone(itemp_mem), &\n")
    ff90.write("     trc_family_name='MB')\n")
    ff90.write("  if(bstatus%check_status())return\n")
    ff90.write("\n")
    ff90.write("  if(this%use_c13)then\n")
    ff90.write("    trcid = betrtracer_vars%id_trc_beg_Bm+Bm_cnt*nelm+c13_loc-1\n")
    ff90.write("    call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = trcid, trc_name='MB_live_C13',&\n")
    ff90.write("      is_trc_mobile=.true., is_trc_advective = .false., &\n")
    ff90.write("      trc_group_id = betrtracer_vars%id_trc_Bm, trc_group_mem = addone(itemp_mem), &\n")
    ff90.write("      trc_family_name='MB')\n")
    ff90.write("    if(bstatus%check_status())return\n")
    ff90.write("  endif\n")
    ff90.write("\n")
    ff90.write("  if(this%use_c14)then\n")
    ff90.write("    trcid = betrtracer_vars%id_trc_beg_Bm+Bm_cnt*nelm+c14_loc-1\n")
    ff90.write("    call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = trcid, trc_name='MB_live_C14', &\n")
    ff90.write("      is_trc_mobile=.true., is_trc_advective = .false., &\n")
    ff90.write("      trc_group_id = betrtracer_vars%id_trc_Bm,  trc_group_mem = addone(itemp_mem), &\n")
    ff90.write("      trc_family_name='MB')\n")
    ff90.write("    if(bstatus%check_status())return\n")
    ff90.write("  endif\n")
    ff90.write("  Bm_cnt=Bm_cnt+1\n")
    ff90.write("\n")
    ff90.write("  trcid = betrtracer_vars%id_trc_beg_Bm+Bm_cnt*nelm+c_loc-1\n")
    ff90.write("  call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = trcid, trc_name='MB_dead', &\n")
    ff90.write("    is_trc_mobile=.true., is_trc_advective = .false., &\n")
    ff90.write("    trc_group_id = betrtracer_vars%id_trc_Bm, trc_group_mem = addone(itemp_mem), &\n")
    ff90.write("    trc_family_name='MB')\n")
    ff90.write("  if(bstatus%check_status())return\n")
    ff90.write("\n")
    ff90.write("  if(this%use_c13)then\n")
    ff90.write("    trcid = betrtracer_vars%id_trc_beg_Bm+Bm_cnt*nelm+c13_loc-1\n")
    ff90.write("    call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = trcid, trc_name='MB_dead_C13',&\n")
    ff90.write("      is_trc_mobile=.true., is_trc_advective = .false., &\n")
    ff90.write("      trc_group_id = betrtracer_vars%id_trc_Bm, trc_group_mem = addone(itemp_mem), &\n")
    ff90.write("      trc_family_name='MB')\n")
    ff90.write("    if(bstatus%check_status())return\n")
    ff90.write("  endif\n")
    ff90.write("\n")
    ff90.write("  if(this%use_c14)then\n")
    ff90.write("    trcid = betrtracer_vars%id_trc_beg_Bm+Bm_cnt*nelm+c14_loc-1\n")
    ff90.write("    call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = trcid, trc_name='MB_dead_C14', &\n")
    ff90.write("      is_trc_mobile=.true., is_trc_advective = .false., &\n")
    ff90.write("      trc_group_id = betrtracer_vars%id_trc_Bm,  trc_group_mem = addone(itemp_mem), &\n")
    ff90.write("      trc_family_name='MB')\n")
    ff90.write("    if(bstatus%check_status())return\n")
    ff90.write("  endif\n")
    ff90.write("\n")
    ff90.write("  itemp_mem=0\n")
    ff90.write("  trcid =  betrtracer_vars%id_trc_beg_dom+c_loc-1\n")
    ff90.write("  call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = trcid                       , &\n")
    ff90.write("     trc_name='DOM_C', is_trc_mobile=.true., is_trc_advective = .true. , &\n")
    ff90.write("     trc_group_id = betrtracer_vars%id_trc_dom, trc_group_mem = addone(itemp_mem), &\n")
    ff90.write("     is_trc_volatile=.false., is_trc_adsorb = .true., trc_adsorbid=addone(itemp_ads) , &\n")
    ff90.write("     trc_adsorbgroupid=addone(itemp_ads_grp), trc_sorpisotherm='LANGMUIR'            , &\n")
    ff90.write("     is_trc_dom=.true.,trc_family_name='DOM')\n")
    ff90.write("  if(bstatus%check_status())return\n")
    ff90.write("\n")
    ff90.write("  trcid = betrtracer_vars%id_trc_beg_dom+e_loc-1\n")
    ff90.write("  call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = trcid                       , &\n")
    ff90.write("     trc_name='DOM_e', is_trc_mobile=.true., is_trc_advective = .true.  , &\n")
    ff90.write("     trc_group_id = betrtracer_vars%id_trc_dom, trc_group_mem = addone(itemp_mem), &\n")
    ff90.write("     is_trc_volatile=.false., is_trc_adsorb = .true., trc_adsorbid=addone(itemp_ads) , &\n")
    ff90.write("     trc_adsorbgroupid=itemp_ads_grp, trc_sorpisotherm='LANGMUIR'                    , &\n")
    ff90.write("     is_trc_dom=.true., trc_family_name='DOM')\n")
    ff90.write("  if(bstatus%check_status())return\n")
    ff90.write("\n")
    ff90.write("  if(this%use_c13)then\n")
    ff90.write("    trcid = betrtracer_vars%id_trc_beg_dom+c13_loc-1\n")
    ff90.write("    call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = trcid                     , &\n")
    ff90.write("      trc_name='DOM_C13', is_trc_mobile=.true., is_trc_advective = .true. , &\n")
    ff90.write("      trc_group_id = betrtracer_vars%id_trc_dom, trc_group_mem = addone(itemp_mem), &\n")
    ff90.write("      is_trc_volatile=.false., is_trc_adsorb = .true., trc_adsorbid=addone(itemp_ads) , &\n")
    ff90.write("      trc_adsorbgroupid=itemp_ads_grp,trc_sorpisotherm='LANGMUIR'                     , &\n")
    ff90.write("      is_trc_dom=.true., trc_family_name='DOM')\n")
    ff90.write("    if(bstatus%check_status())return\n")
    ff90.write("  endif\n")
    ff90.write("\n")
    ff90.write("  if(this%use_c14)then\n")
    ff90.write("    trcid=betrtracer_vars%id_trc_beg_dom+c14_loc-1\n")
    ff90.write("    call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = trcid                     , &\n")
    ff90.write("      trc_name='DOM_C14', is_trc_mobile=.true., is_trc_advective = .true. , &\n")
    ff90.write("      trc_group_id = betrtracer_vars%id_trc_dom, trc_group_mem = addone(itemp_mem), &\n")
    ff90.write("      is_trc_volatile=.false., is_trc_adsorb = .true., trc_adsorbid=addone(itemp_ads) , &\n")
    ff90.write("      trc_adsorbgroupid=itemp_ads_grp, trc_sorpisotherm='LANGMUIR'                    , &\n")
    ff90.write("      is_trc_dom=.true., trc_family_name='DOM')\n")
    ff90.write("    if(bstatus%check_status())return\n")
    ff90.write("  endif\n")
    ff90.write("\n")
    ff90.write("  itemp_mem=0\n")
    ff90.write("  trcid =  betrtracer_vars%id_trc_beg_pom+c_loc-1\n")
    ff90.write("  call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = trcid, trc_name='POM_C' ,    &\n")
    ff90.write("     is_trc_mobile=.false., is_trc_advective = .false., &\n")
    ff90.write("     trc_group_id = betrtracer_vars%id_trc_pom, trc_group_mem= addone(itemp_mem), &\n")
    ff90.write("     trc_family_name='POM')\n")
    ff90.write("  if(bstatus%check_status())return\n")
    ff90.write("\n")
    ff90.write("  trcid = betrtracer_vars%id_trc_beg_pom+e_loc-1\n")
    ff90.write("  call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = trcid, trc_name='POM_e' ,    &\n")
    ff90.write("     is_trc_mobile=.false., is_trc_advective = .false., &\n")
    ff90.write("     trc_group_id = betrtracer_vars%id_trc_pom, trc_group_mem= addone(itemp_mem), &\n")
    ff90.write("     trc_family_name='POM')\n")
    ff90.write("  if(bstatus%check_status())return\n")
    ff90.write("\n")
    ff90.write("  if(this%use_c13)then\n")
    ff90.write("    trcid = betrtracer_vars%id_trc_beg_pom+c13_loc-1\n")
    ff90.write("    call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = trcid, trc_name='POM_C13' ,    &\n")
    ff90.write("      is_trc_mobile=.false., is_trc_advective = .false., &\n")
    ff90.write("      trc_group_id = betrtracer_vars%id_trc_pom, trc_group_mem= addone(itemp_mem), &\n")
    ff90.write("      trc_family_name='POM')\n")
    ff90.write("    if(bstatus%check_status())return\n")
    ff90.write("  endif\n")
    ff90.write("\n")
    ff90.write("  if(this%use_c14)then\n")
    ff90.write("    trcid=betrtracer_vars%id_trc_beg_pom+c14_loc-1\n")
    ff90.write("    call betrtracer_vars%set_tracer(bstatus=bstatus,trc_id = trcid, trc_name='POM_C14' ,  &\n")
    ff90.write("      is_trc_mobile=.false., is_trc_advective = .false., &\n")
    ff90.write("      trc_group_id = betrtracer_vars%id_trc_pom, trc_group_mem= addone(itemp_mem), &\n")
    ff90.write("      trc_family_name='POM')\n")
    ff90.write("    if(bstatus%check_status())return\n")
    ff90.write("  endif\n")
    ff90.write("\n")
    ff90.write("  end associate\n")
    ff90.write("  end subroutine set_tracer\n")
    ff90.write("!-------------------------------------------------------------------------------\n")
    ff90.write("  subroutine set_boundary_conditions(this, bounds, num_soilc, filter_soilc, dz_top, betrtracer_vars, &\n")
    ff90.write("   biophysforc, biogeo_flux, tracercoeff_vars, tracerboundarycond_vars, betr_status)\n")
    ff90.write("  !\n")
    ff90.write("  ! !DESCRIPTION:\n")
    ff90.write("  ! set up boundary conditions for tracer movement\n")
    ff90.write("  !\n")
    ff90.write("  ! !USES:\n")
    ff90.write("  use betr_ctrl              , only : iulog  => biulog\n")
    ff90.write("  use TracerBoundaryCondType , only : tracerboundarycond_type\n")
    ff90.write("  use bshr_log_mod           , only : errMsg => shr_log_errMsg\n")
    ff90.write("  use BeTRTracerType         , only : betrtracer_type\n")
    ff90.write("  use betr_varcon            , only : rgas => brgas\n")
    ff90.write("  use BeTR_biogeoFluxType    , only : betr_biogeo_flux_type\n")
    ff90.write("  use BetrStatusType         , only : betr_status_type\n")
    ff90.write("  use UnitConvertMod          , only : ppm2molv\n")
    ff90.write("  use TracerCoeffType         , only : tracercoeff_type\n")
    ff90.write("  implicit none\n")
    ff90.write("  ! !ARGUMENTS:\n")
    ff90.write("  class("+app_name+"_bgc_reaction_type) , intent(inout)    :: this        !\n")
    ff90.write("  type(bounds_type)                 , intent(in)    :: bounds             !\n")
    ff90.write("  integer                           , intent(in)    :: num_soilc                  ! number of columns in column filter_soilc\n")
    ff90.write("  integer                           , intent(in)    :: filter_soilc(:)            ! column filter_soilc\n")
    ff90.write("  type(betrtracer_type)             , intent(in)    :: betrtracer_vars            !\n")
    ff90.write("  real(r8)                          , intent(in)    :: dz_top(bounds%begc: )      !\n")
    ff90.write("  type(betr_biogeophys_input_type)  , intent(in)    :: biophysforc\n")
    ff90.write("  type(betr_biogeo_flux_type)       , intent(in)    :: biogeo_flux\n")
    ff90.write("  type(tracercoeff_type)             , intent(in)   :: tracercoeff_vars\n")
    ff90.write("  type(tracerboundarycond_type)     , intent(inout) :: tracerboundarycond_vars !\n")
    ff90.write("  type(betr_status_type)            , intent(out)   :: betr_status\n")
    ff90.write("\n")
    ff90.write("  ! !LOCAL VARIABLES:\n")
    ff90.write("  integer            :: fc, c\n")
    ff90.write("  character(len=255) :: subname = 'set_boundary_conditions'\n")
    ff90.write("  real(r8) :: irt   !the inverse of R*T\n")
    ff90.write("\n")
    ff90.write("  call betr_status%reset()\n")
    ff90.write("  SHR_ASSERT_ALL((ubound(dz_top)  == (/bounds%endc/)),   errMsg(mod_filename,__LINE__), betr_status)\n")
    ff90.write("\n")
    ff90.write("  ! remove compiler warnings for unused dummy args\n")
    ff90.write("  if (this%dummy_compiler_warning)      continue\n")
    ff90.write("  if (size(biogeo_flux%qflx_adv_col)>0) continue\n")
    ff90.write("  associate(                                                    &\n")
    ff90.write("         groupid    => betrtracer_vars%groupid              , &\n")
    ff90.write("         n2_ppmv    => biophysforc%n2_ppmv_col              , &\n")
    ff90.write("         o2_ppmv    => biophysforc%o2_ppmv_col              , &\n")
    ff90.write("         ar_ppmv    => biophysforc%ar_ppmv_col              , &\n")
    ff90.write("         co2_ppmv   => biophysforc%co2_ppmv_col             , &\n")
    ff90.write("         ch4_ppmv   => biophysforc%ch4_ppmv_col             , &\n")
    ff90.write("         pbot_pa    => biophysforc%forc_pbot_downscaled_col , &\n")
    ff90.write("         tair       => biophysforc%forc_t_downscaled_col    , &\n")
    ff90.write("         id_trc_beg_dom=>betrtracer_vars%id_trc_beg_dom     , &\n")
    ff90.write("         id_trc_end_dom=>betrtracer_vars%id_trc_end_dom       &\n")
    ff90.write("     )\n")
    ff90.write("\n")
    ff90.write("  do fc = 1, num_soilc\n")
    ff90.write("    c = filter_soilc(fc)\n")
    ff90.write("    tracerboundarycond_vars%tracer_gwdif_concflux_top_col(c,1:2,:) = 0._r8\n")
    ff90.write("    tracerboundarycond_vars%bot_concflux_col(c,1,:)  = 0._r8                        !zero flux boundary condition for diffusion\n")
    ff90.write("    tracerboundarycond_vars%condc_toplay_col(c,:)    = 0._r8\n")
    ff90.write("    !set value for specific groups\n")
    ff90.write("    tracerboundarycond_vars%tracer_gwdif_concflux_top_col(c,1:2,betrtracer_vars%id_trc_n2)    =ppm2molv(pbot_pa(c), n2_ppmv(c), tair(c))    !mol m-3, contant boundary condition\n")
    ff90.write("    tracerboundarycond_vars%tracer_gwdif_concflux_top_col(c,1:2,betrtracer_vars%id_trc_o2)    =ppm2molv(pbot_pa(c), o2_ppmv(c), tair(c))!mol m-3, contant boundary condition\n")
    ff90.write("    tracerboundarycond_vars%tracer_gwdif_concflux_top_col(c,1:2,betrtracer_vars%id_trc_ar)    =ppm2molv(pbot_pa(c), ar_ppmv(c), tair(c))!mol m-3, contant boundary condition\n")
    ff90.write("    tracerboundarycond_vars%tracer_gwdif_concflux_top_col(c,1:2,betrtracer_vars%id_trc_co2x)  =ppm2molv(pbot_pa(c), co2_ppmv(c), tair(c))!mol m-3, contant boundary condition\n")
    ff90.write("    tracerboundarycond_vars%tracer_gwdif_concflux_top_col(c,1:2,betrtracer_vars%id_trc_ch4)   =ppm2molv(pbot_pa(c), ch4_ppmv(c), tair(c))!mol m-3, contant boundary condition\n")
    ff90.write("    tracerboundarycond_vars%tracer_gwdif_concflux_top_col(c,1:2,id_trc_beg_dom:id_trc_end_dom)= 0._r8            !mol m-3, contant boundary condition, as concentration\n")
    ff90.write("\n")
    ff90.write("    tracerboundarycond_vars%condc_toplay_col(c,groupid(betrtracer_vars%id_trc_n2))           = 2._r8*1.837e-5_r8/dz_top(c)  !m/s surface conductance\n")
    ff90.write("    tracerboundarycond_vars%condc_toplay_col(c,groupid(betrtracer_vars%id_trc_o2))           = 2._r8*1.713e-5_r8/dz_top(c)  !m/s surface conductance\n")
    ff90.write("    tracerboundarycond_vars%condc_toplay_col(c,groupid(betrtracer_vars%id_trc_ar))           = 2._r8*1.532e-5_r8/dz_top(c)  !m/s surface conductance\n")
    ff90.write("    tracerboundarycond_vars%condc_toplay_col(c,groupid(betrtracer_vars%id_trc_co2x))         = 2._r8*1.399e-5_r8/dz_top(c)  !m/s surface conductance\n")
    ff90.write("    tracerboundarycond_vars%condc_toplay_col(c,groupid(betrtracer_vars%id_trc_ch4))          = 2._r8*1.808e-5_r8/dz_top(c)  !m/s surface conductance\n")
    ff90.write("  enddo\n")
    ff90.write("\n")
    ff90.write("  end associate\n")
    ff90.write("  end subroutine set_boundary_conditions\n")
    ff90.write("!-------------------------------------------------------------------------------\n")
    ff90.write("  subroutine calc_bgc_reaction(this, bounds, col, lbj, ubj, num_soilc, filter_soilc,               &\n")
    ff90.write("    num_soilp,filter_soilp, jtops, dtime, betrtracer_vars, tracercoeff_vars,  biophysforc, &\n")
    ff90.write("    tracerstate_vars, tracerflux_vars, tracerboundarycond_vars, plant_soilbgc, &\n")
    ff90.write("    biogeo_flux,  betr_status)\n")
    ff90.write("  !\n")
    ff90.write("  ! !DESCRIPTION:\n")
    ff90.write("  ! do bgc reaction\n")
    ff90.write("  !\n")
    ff90.write("  ! !USES:\n")
    ff90.write("  use TracerBoundaryCondType , only : tracerboundarycond_type\n")
    ff90.write("  use tracerfluxType         , only : tracerflux_type\n")
    ff90.write("  use tracerstatetype        , only : tracerstate_type\n")
    ff90.write("  use tracercoeffType        , only : tracercoeff_type\n")
    ff90.write("  use BetrTracerType         , only : betrtracer_type\n")
    ff90.write("  use PlantSoilBGCMod        , only : plant_soilbgc_type\n")
    ff90.write("  use BetrStatusType         , only : betr_status_type\n")
    ff90.write("  use betr_columnType        , only : betr_column_type\n")
    ff90.write("  use BeTR_biogeoFluxType    , only : betr_biogeo_flux_type\n")
    ff90.write("  use BeTR_biogeoStateType   , only : betr_biogeo_state_type\n")
    ff90.write("  implicit none\n")
    ff90.write("  !ARGUMENTS\n")
    ff90.write("  class("+app_name+"_bgc_reaction_type) , intent(inout) :: this !\n")
    ff90.write("  type(bounds_type)                 , intent(in)    :: bounds      ! bounds\n")
    ff90.write("  type(betr_column_type)            , intent(in)    :: col\n")
    ff90.write("  integer                           , intent(in)    :: num_soilc    ! number of columns in column filter\n")
    ff90.write("  integer                           , intent(in)    :: filter_soilc(:)    ! column filter\n")
    ff90.write("  integer                           , intent(in)    :: num_soilp\n")
    ff90.write("  integer                           , intent(in)    :: filter_soilp(:)\n")
    ff90.write("  integer                           , intent(in)    :: jtops( : )  ! top index of each column\n")
    ff90.write("  integer                           , intent(in)    :: lbj, ubj    ! lower and upper bounds, make sure they are > 0\n")
    ff90.write("  real(r8)                          , intent(in)    :: dtime                       ! model time step\n")
    ff90.write("  type(betrtracer_type)             , intent(in)    :: betrtracer_vars             ! betr configuration information\n")
    ff90.write("  type(betr_biogeophys_input_type)  , intent(inout) :: biophysforc\n")
    ff90.write("  type(tracercoeff_type)            , intent(inout) :: tracercoeff_vars\n")
    ff90.write("  type(tracerstate_type)            , intent(inout) :: tracerstate_vars\n")
    ff90.write("  type(tracerflux_type)             , intent(inout) :: tracerflux_vars\n")
    ff90.write("  type(tracerboundarycond_type)     , intent(inout) :: tracerboundarycond_vars !\n")
    ff90.write("  class(plant_soilbgc_type)         , intent(inout) :: plant_soilbgc\n")
    ff90.write("  type(betr_biogeo_flux_type)       , intent(inout) :: biogeo_flux\n")
    ff90.write("  type(betr_status_type)            , intent(out)   :: betr_status\n")
    ff90.write("  character(len=*)                 , parameter     :: subname ='calc_bgc_reaction'\n")
    ff90.write("\n")
    ff90.write("  integer :: c, fc, j\n")
    ff90.write("  character(len=5) :: laystr\n")
    ff90.write("  logical :: is_surflit  !surface litter layer?\n")
    ff90.write("  integer :: nstates\n")
    ff90.write("  real(r8), allocatable :: ystates0(:)\n")
    ff90.write("  real(r8), allocatable :: ystatesf(:)\n")
    ff90.write("\n")
    ff90.write("  associate(                                                                      &\n")
    ff90.write("    tracer_mobile_phase            => tracerstate_vars%tracer_conc_mobile_col  ,  &\n")
    ff90.write("    tracer_flx_netpro_vr           => tracerflux_vars%tracer_flx_netpro_vr_col    &\n")
    ff90.write("  )\n")
    ff90.write("\n")
    ff90.write("  call betr_status%reset()\n")
    ff90.write("\n")
    ff90.write("  nstates = this%"+app_name+"_bgc_index%nstvars\n")
    ff90.write("  allocate(ystates0(nstates))\n")
    ff90.write("  allocate(ystatesf(nstates))\n")
    ff90.write("\n")
    ff90.write("  call this%set_bgc_forc(bounds, col, lbj, ubj, jtops, num_soilc, filter_soilc, &\n")
    ff90.write("    biophysforc, plant_soilbgc, betrtracer_vars, tracercoeff_vars, tracerstate_vars,betr_status)\n")
    ff90.write("\n")
    ff90.write("  do j = lbj, ubj\n")
    ff90.write("    do fc = 1, num_soilc\n")
    ff90.write("      c = filter_soilc(fc)\n")
    ff90.write("      if(j<jtops(c))cycle\n")
    ff90.write("      is_surflit=(j<=0)\n")
    ff90.write("      !do bgc reaction\n")
    ff90.write("      call this%"+app_name+"_bgc(c,j)%runbgc(is_surflit, dtime, this%"+app_name+"_forc(c,j), nstates, ystates0, ystatesf, betr_status)\n")
    ff90.write("      if(betr_status%check_status())then\n")
    ff90.write("        write(laystr,'(I2.2)')j\n")
    ff90.write("        betr_status%msg=trim(betr_status%msg)//' lay '//trim(laystr)\n")
    ff90.write("        return\n")
    ff90.write("      endif\n")
    ff90.write("\n")
    ff90.write("      call this%retrieve_output(c, j, nstates, ystates0, ystatesf, dtime, betrtracer_vars, tracerflux_vars,&\n")
    ff90.write("        tracerstate_vars, plant_soilbgc, biogeo_flux)\n")
    ff90.write("\n")
    ff90.write("    enddo\n")
    ff90.write("  enddo\n")
    ff90.write("\n")
    ff90.write("  !update phase change coefficients for tracers involved in sorptive reactions\n")
    ff90.write("  call this%update_sorpphase_coeff(bounds, col, lbj, ubj, jtops, num_soilc, filter_soilc, &\n")
    ff90.write("    betrtracer_vars, tracerstate_vars, tracercoeff_vars)\n")
    ff90.write("  deallocate(ystates0)\n")
    ff90.write("  deallocate(ystatesf)\n")
    ff90.write("  end associate\n")
    ff90.write("  end subroutine calc_bgc_reaction\n")
    ff90.write("  !-------------------------------------------------------------------------------\n")
    ff90.write("  subroutine do_tracer_equilibration(this, bounds, lbj, ubj, jtops, num_soilc, filter_soilc, &\n")
    ff90.write("    betrtracer_vars, tracercoeff_vars, tracerstate_vars, betr_status)\n")
    ff90.write("  !\n")
    ff90.write("  ! DESCRIPTION:\n")
    ff90.write("  ! requilibrate tracers that has solid and mobile phases\n")
    ff90.write("  ! using the theory of mass action.\n")
    ff90.write("  !\n")
    ff90.write("  ! !USES:\n")
    ff90.write("  !\n")
    ff90.write("  use tracerstatetype , only : tracerstate_type\n")
    ff90.write("  use tracercoeffType , only : tracercoeff_type\n")
    ff90.write("  use BeTRTracerType  , only : betrtracer_type\n")
    ff90.write("  use BetrStatusType  , only : betr_status_type\n")
    ff90.write("  implicit none\n")
    ff90.write("  ! !ARGUMENTS:\n")
    ff90.write("  class("+app_name+"_bgc_reaction_type) , intent(inout)    :: this\n")
    ff90.write("  type(bounds_type)                 , intent(in)    :: bounds\n")
    ff90.write("  integer                           , intent(in)    :: lbj, ubj\n")
    ff90.write("  integer                           , intent(in)    :: jtops(bounds%begc: )        ! top label of each column\n")
    ff90.write("  integer                           , intent(in)    :: num_soilc\n")
    ff90.write("  integer                           , intent(in)    :: filter_soilc(:)\n")
    ff90.write("  type(betrtracer_type)             , intent(in)    :: betrtracer_vars\n")
    ff90.write("  type(tracercoeff_type)            , intent(in)    :: tracercoeff_vars\n")
    ff90.write("  type(tracerstate_type)            , intent(inout) :: tracerstate_vars\n")
    ff90.write("  type(betr_status_type)            , intent(out)   :: betr_status\n")
    ff90.write("  !local variables\n")
    ff90.write("  character(len=255) :: subname = 'do_tracer_equilibration'\n")
    ff90.write("  call betr_status%reset()\n")
    ff90.write("  SHR_ASSERT_ALL((ubound(jtops) == (/bounds%endc/)), errMsg(mod_filename,__LINE__), betr_status)\n")
    ff90.write("\n")
    ff90.write("  ! remove compiler warnings for unused dummy args\n")
    ff90.write("  if (this%dummy_compiler_warning)                          continue\n")
    ff90.write("  if (bounds%begc > 0)                                      continue\n")
    ff90.write("  if (ubj > lbj)                                            continue\n")
    ff90.write("  if (size(jtops) > 0)                                      continue\n")
    ff90.write("  if (num_soilc > 0)                                        continue\n")
    ff90.write("  if (size(filter_soilc) > 0)                               continue\n")
    ff90.write("  if (len(betrtracer_vars%betr_simname) > 0)                continue\n")
    ff90.write("  if (size(tracerstate_vars%tracer_conc_surfwater_col) > 0) continue\n")
    ff90.write("  !continue on the simulation type, an implementation of aqueous chemistry will be\n")
    ff90.write("  !employed to separate out the adsorbed phase\n")
    ff90.write("  !It should be noted that this formulation excludes the use of linear isotherm, which\n")
    ff90.write("  !can be integrated through the retardation factor\n")
    ff90.write("  end subroutine do_tracer_equilibration\n")
    ff90.write("!-----------------------------------------------------------------------\n")
    ff90.write("  subroutine InitCold(this, bounds, col, betrtracer_vars, biophysforc, tracerstate_vars)\n")
    ff90.write("  !\n")
    ff90.write("  ! !DESCRIPTION:\n")
    ff90.write("  ! do cold initialization\n")
    ff90.write("  !\n")
    ff90.write("  ! !USES:\n")
    ff90.write("  use BeTRTracerType      , only : BeTRTracer_Type\n")
    ff90.write("  use tracerstatetype     , only : tracerstate_type\n")
    ff90.write("  use betr_varcon         , only : spval => bspval, ispval => bispval\n")
    ff90.write("  use BeTR_landvarconType , only : landvarcon  => betr_landvarcon\n")
    ff90.write("  use betr_columnType     , only : betr_column_type\n")
    ff90.write("  implicit none\n")
    ff90.write("  ! !ARGUMENTS:\n")
    ff90.write("  class("+app_name+"_bgc_reaction_type) , intent(inout)    :: this\n")
    ff90.write("  type(bounds_type)                 , intent(in)    :: bounds\n")
    ff90.write("  type(betr_column_type)            , intent(in)    :: col\n")
    ff90.write("  type(BeTRTracer_Type)             , intent(in)    :: betrtracer_vars\n")
    ff90.write("  type(betr_biogeophys_input_type)  , intent(in)    :: biophysforc\n")
    ff90.write("  type(tracerstate_type)            , intent(inout) :: tracerstate_vars\n")
    ff90.write("  !\n")
    ff90.write("  ! !LOCAL VARIABLES:\n")
    ff90.write("  integer :: p, c, l, k, j\n")
    ff90.write("  integer :: fc       ! filter_soilc index\n")
    ff90.write("  integer :: begc, endc\n")
    ff90.write("  integer :: begg, endg\n")
    ff90.write("  integer :: trcid\n")
    ff90.write("  begc = bounds%begc; endc= bounds%endc\n")
    ff90.write("  begg = bounds%begg; endg= bounds%endg\n")
    ff90.write("  trcid = betrtracer_vars%id_trc_beg_Bm\n")
    ff90.write("\n")
    ff90.write("  do c = bounds%begc, bounds%endc\n")
    ff90.write("    !dual phase tracers\n")
    ff90.write("    tracerstate_vars%tracer_conc_mobile_col(c,:, :)          = 0._r8\n")
    ff90.write("    tracerstate_vars%tracer_conc_surfwater_col(c,:)          = 0._r8\n")
    ff90.write("    tracerstate_vars%tracer_conc_aquifer_col(c,:)            = 0._r8\n")
    ff90.write("    tracerstate_vars%tracer_conc_grndwater_col(c,:)          = 0._r8\n")
    ff90.write("    if(betrtracer_vars%nsolid_equil_tracers>0)then\n")
    ff90.write("      tracerstate_vars%tracer_conc_solid_equil_col(c, :, :) = 0._r8\n")
    ff90.write("    endif\n")
    ff90.write("    tracerstate_vars%tracer_soi_molarmass_col(c,:)          = 0._r8\n")
    ff90.write("    !initialize microbial biomass\n")
    ff90.write("    tracerstate_vars%tracer_conc_mobile_col(c,:,trcid) = 1.e-2_r8\n")
    ff90.write("  enddo\n")
    ff90.write("  end subroutine InitCold\n")
    ff90.write("!-----------------------------------------------------------------------\n")
    ff90.write("  subroutine readParams(this, name_list_buffer, betrtracer_vars)\n")
    ff90.write("  !\n")
    ff90.write("  ! !DESCRIPTION:\n")
    ff90.write("  ! read in module specific parameters\n")
    ff90.write("  !\n")
    ff90.write("  ! !USES:\n")
    ff90.write("  use BeTRTracerType , only : BeTRTracer_Type\n")
    ff90.write("  implicit none\n")
    ff90.write("  ! !ARGUMENTS:\n")
    ff90.write("  class("+app_name+"_bgc_reaction_type) , intent(inout)    :: this\n")
    ff90.write("  type(BeTRTracer_Type)             , intent(inout) :: betrtracer_vars\n")
    ff90.write("  character(len=*)                  , intent(in)  :: name_list_buffer\n")
    ff90.write("  ! remove compiler warnings for unused dummy args\n")
    ff90.write("  if (this%dummy_compiler_warning)           continue\n")
    ff90.write("  if (len(betrtracer_vars%betr_simname) > 0) continue\n")
    ff90.write("\n")
    ff90.write("  !do nothing here\n")
    ff90.write("  end subroutine readParams\n")
    ff90.write("!-------------------------------------------------------------------------------\n")
    ff90.write("  subroutine retrieve_biogeoflux(this, num_soilc, filter_soilc, tracerflux_vars, &\n")
    ff90.write("    betrtracer_vars, biogeo_flux)\n")
    ff90.write("  !\n")
    ff90.write("  ! DESCRIPTION\n")
    ff90.write("  ! retrieve fluxes after bgc update\n")
    ff90.write("  ! USES\n")
    ff90.write("  use tracerfluxType           , only : tracerflux_type\n")
    ff90.write("  use BeTR_decompMod           , only : betr_bounds_type\n")
    ff90.write("  use BeTRTracerType           , only : BeTRTracer_Type\n")
    ff90.write("  use BeTR_biogeoFluxType      , only : betr_biogeo_flux_type\n")
    ff90.write("  implicit none\n")
    ff90.write("  class("+app_name+"_bgc_reaction_type) , intent(inout) :: this    !\n")
    ff90.write("  integer                          , intent(in)    :: num_soilc   ! number of columns in column filter\n")
    ff90.write("  integer                          , intent(in)    :: filter_soilc(:)             ! column filter\n")
    ff90.write("  type(betrtracer_type)            , intent(in)    :: betrtracer_vars             ! betr configuration information\n")
    ff90.write("  type(tracerflux_type)            , intent(in)    :: tracerflux_vars\n")
    ff90.write("  type(betr_biogeo_flux_type)      , intent(inout) :: biogeo_flux\n")

    ff90.write("  ! remove compiler warnings for unused dummy args\n")
    ff90.write("  if (this%dummy_compiler_warning)                          continue\n")
    ff90.write("  if (num_soilc > 0)                                        continue\n")
    ff90.write("  if (size(filter_soilc) > 0)                               continue\n")
    ff90.write("  if (len(betrtracer_vars%betr_simname) > 0)                continue\n")
    ff90.write("  if (size(tracerflux_vars%tracer_flx_top_soil_col) > 0)    continue\n")
    ff90.write("  end subroutine retrieve_biogeoflux\n")
    ff90.write("!----------------------------------------------------------------------\n")
    ff90.write("  subroutine retrieve_lnd2atm(this, bounds, num_soilc, filter_soilc, tracerflux_vars, &\n")
    ff90.write("    betrtracer_vars, biogeo_flux)\n")
    ff90.write("  !\n")
    ff90.write("  ! DESCRIPTION\n")
    ff90.write("  ! retrieve fluxes from land to atmosphere\n")
    ff90.write("  ! USES\n")
    ff90.write("  use tracerfluxType           , only : tracerflux_type\n")
    ff90.write("  use BeTR_decompMod           , only : betr_bounds_type\n")
    ff90.write("  use BeTRTracerType           , only : BeTRTracer_Type\n")
    ff90.write("  use BeTR_biogeoFluxType      , only : betr_biogeo_flux_type\n")
    ff90.write("  implicit none\n")
    ff90.write("  class("+app_name+"_bgc_reaction_type) , intent(inout) :: this     !\n")
    ff90.write("  type(betr_bounds_type)           , intent(in)    :: bounds     ! bounds\n")
    ff90.write("  integer                          , intent(in)    :: num_soilc   ! number of columns in column filter\n")
    ff90.write("  integer                          , intent(in)    :: filter_soilc(:)             ! column filter\n")
    ff90.write("  type(betrtracer_type)            , intent(in)    :: betrtracer_vars             ! betr configuration information\n")
    ff90.write("  type(tracerflux_type)            , intent(in)    :: tracerflux_vars\n")
    ff90.write("  type(betr_biogeo_flux_type)      , intent(inout) :: biogeo_flux\n")
    ff90.write("  if (this%dummy_compiler_warning) continue\n")
    ff90.write("  if (bounds%begc > 0)             continue\n")
    ff90.write("  end subroutine retrieve_lnd2atm\n")
    ff90.write("!-------------------------------------------------------------------------------\n")
    ff90.write("  subroutine debug_info(this, bounds, num_soilc, filter_soilc, dzsoi, betrtracer_vars, tracerstate_vars, header, betr_status)\n")
    ff90.write("  !\n")
    ff90.write("  ! DESCRIPTION\n")
    ff90.write("  ! write debug information\n")
    ff90.write("  ! USES\n")
    ff90.write("  use BeTRTracerType           , only : BeTRTracer_Type\n")
    ff90.write("  use tracerstatetype          , only : tracerstate_type\n")
    ff90.write("  use BeTR_decompMod           , only : betr_bounds_type\n")
    ff90.write("  ! !ARGUMENTS:\n")
    ff90.write("  implicit none\n")
    ff90.write("  class("+app_name+"_bgc_reaction_type) , intent(inout) :: this      !\n")
    ff90.write("  type(betr_bounds_type)               , intent(in) :: bounds    ! bounds\n")
    ff90.write("  integer                              , intent(in) :: num_soilc  ! number of columns in column filter\n")
    ff90.write("  integer                              , intent(in) :: filter_soilc(:)    ! column filter\n")
    ff90.write("  real(r8)                             , intent(in) :: dzsoi(bounds%begc: ,bounds%lbj: )\n")
    ff90.write("  type(betrtracer_type)                , intent(in) :: betrtracer_vars   ! betr configuration information\n")
    ff90.write("  type(tracerstate_type)               , intent(in) :: tracerstate_vars\n")
    ff90.write("  character(len=*)                     , intent(in) :: header\n")
    ff90.write("  type(betr_status_type)               , intent(out):: betr_status\n")
    ff90.write("  call betr_status%reset()\n")
    ff90.write("  SHR_ASSERT_ALL((ubound(dzsoi)  == (/bounds%endc, bounds%ubj/)),   errMsg(mod_filename,__LINE__), betr_status)\n")
    ff90.write("\n")
    ff90.write("  if (this%dummy_compiler_warning) continue\n")
    ff90.write("  end subroutine debug_info\n")
    ff90.write("!----------------------------------------------------------------------\n")
    ff90.write("  subroutine retrieve_biostates(this, bounds, lbj, ubj, jtops,num_soilc, filter_soilc, &\n")
    ff90.write("    betrtracer_vars, tracerstate_vars, biogeo_state, betr_status)\n")
    ff90.write("  !\n")
    ff90.write("  ! DESCRIPTION\n")
    ff90.write("  !retrieve state variables for lsm mass balance check\n")
    ff90.write("  ! USES\n")
    ff90.write("  use tracer_varcon, only : catomw, natomw, patomw, c13atomw, c14atomw\n")
    ff90.write("  use BeTR_decompMod           , only : betr_bounds_type\n")
    ff90.write("  use BeTRTracerType           , only : BeTRTracer_Type\n")
    ff90.write("  use tracerstatetype          , only : tracerstate_type\n")
    ff90.write("  use BeTR_biogeoStateType     , only : betr_biogeo_state_type\n")
    ff90.write("  implicit none\n")
    ff90.write("  class("+app_name+"_bgc_reaction_type) , intent(inout) :: this           !\n")
    ff90.write("  type(betr_bounds_type)               , intent(in)  :: bounds            ! bounds\n")
    ff90.write("  integer                              , intent(in) :: lbj, ubj\n")
    ff90.write("  integer                              , intent(in) :: jtops(bounds%begc: )\n")
    ff90.write("  integer                              , intent(in)    :: num_soilc   ! number of columns in column filter\n")
    ff90.write("  integer                              , intent(in)    :: filter_soilc(:)    ! column filter\n")
    ff90.write("  type(betrtracer_type)                , intent(in) :: betrtracer_vars       ! betr configuration information\n")
    ff90.write("  type(tracerstate_type)               , intent(inout) :: tracerstate_vars\n")
    ff90.write("  type(betr_biogeo_state_type)         , intent(inout) :: biogeo_state\n")
    ff90.write("  type(betr_status_type)               , intent(out):: betr_status\n")
    ff90.write("  !local variables\n")
    ff90.write("  integer :: nelm\n")
    ff90.write("  integer :: c_loc, c13_loc, c14_loc\n")
    ff90.write("  integer :: c, fc, j, kk\n")
    ff90.write("\n")
    ff90.write("  call betr_status%reset()\n")
    ff90.write("  SHR_ASSERT_ALL((ubound(jtops)  == (/bounds%endc/)),   errMsg(mod_filename,__LINE__), betr_status)\n")
    ff90.write("\n")
    ff90.write("  c_loc=this%"+app_name+"_bgc_index%c_loc\n")
    ff90.write("  c13_loc=this%"+app_name+"_bgc_index%c13_loc\n")
    ff90.write("  c14_loc=this%"+app_name+"_bgc_index%c14_loc\n")
    ff90.write("  nelm =this%"+app_name+"_bgc_index%nelms\n")
    ff90.write("  do j = lbj, ubj\n")
    ff90.write("    do fc = 1, num_soilc\n")
    ff90.write("      c = filter_soilc(fc)\n")
    ff90.write("      if(j<jtops(c))cycle\n")
    ff90.write("      !add litter\n")
    ff90.write("      do kk = betrtracer_vars%id_trc_beg_litr, betrtracer_vars%id_trc_end_litr, nelm\n")
    ff90.write("        biogeo_state%c12state_vars%totlitc_vr_col(c,j) = biogeo_state%c12state_vars%totlitc_vr_col(c,j) + &\n")
    ff90.write("          catomw * tracerstate_vars%tracer_conc_mobile_col(c, j, kk-1+c_loc)\n")
    ff90.write("        if(this%use_c13)then\n")
    ff90.write("          biogeo_state%c13state_vars%totlitc_vr_col(c,j) = biogeo_state%c13state_vars%totlitc_vr_col(c,j) + &\n")
    ff90.write("            c13atomw * tracerstate_vars%tracer_conc_mobile_col(c, j, kk-1+c13_loc)\n")
    ff90.write("        endif\n")
    ff90.write("        if(this%use_c14)then\n")
    ff90.write("          biogeo_state%c14state_vars%totlitc_vr_col(c,j) = biogeo_state%c14state_vars%totlitc_vr_col(c,j) + &\n")
    ff90.write("            c14atomw * tracerstate_vars%tracer_conc_mobile_col(c, j, kk-1+c14_loc)\n")
    ff90.write("        endif\n")
    ff90.write("      enddo\n")
    ff90.write("\n")
    ff90.write("      !add cwd\n")
    ff90.write("      do kk = betrtracer_vars%id_trc_beg_wood, betrtracer_vars%id_trc_end_wood, nelm\n")
    ff90.write("        biogeo_state%c12state_vars%cwdc_vr_col(c,j) = biogeo_state%c12state_vars%cwdc_vr_col(c,j) + &\n")
    ff90.write("          catomw * tracerstate_vars%tracer_conc_mobile_col(c, j, kk-1+c_loc)\n")
    ff90.write("        if(this%use_c13)then\n")
    ff90.write("          biogeo_state%c13state_vars%cwdc_vr_col(c,j) = biogeo_state%c13state_vars%cwdc_vr_col(c,j) + &\n")
    ff90.write("            c13atomw * tracerstate_vars%tracer_conc_mobile_col(c, j, kk-1+c13_loc)\n")
    ff90.write("        endif\n")
    ff90.write("        if(this%use_c14)then\n")
    ff90.write("          biogeo_state%c14state_vars%cwdc_vr_col(c,j) = biogeo_state%c14state_vars%cwdc_vr_col(c,j) + &\n")
    ff90.write("            c14atomw * tracerstate_vars%tracer_conc_mobile_col(c, j, kk-1+c14_loc)\n")
    ff90.write("        endif\n")
    ff90.write("      enddo\n")
    ff90.write("\n")
    ff90.write("      !Microbial biomass\n")
    ff90.write("      do kk = betrtracer_vars%id_trc_beg_Bm, betrtracer_vars%id_trc_end_Bm-nelm, nelm\n")
    ff90.write("        biogeo_state%c12state_vars%som1c_vr_col(c,j) =  &\n")
    ff90.write("          catomw * tracerstate_vars%tracer_conc_mobile_col(c, j, kk-1+c_loc)\n")
    ff90.write("\n")
    ff90.write("        if(this%use_c13)then\n")
    ff90.write("          biogeo_state%c13state_vars%som1c_vr_col(c,j) = &\n")
    ff90.write("            c13atomw * tracerstate_vars%tracer_conc_mobile_col(c, j, kk-1+c13_loc)\n")
    ff90.write("        endif\n")
    ff90.write("        if(this%use_c14)then\n")
    ff90.write("          biogeo_state%c14state_vars%som1c_vr_col(c,j) =  &\n")
    ff90.write("            c14atomw * tracerstate_vars%tracer_conc_mobile_col(c, j, kk-1+c14_loc)\n")
    ff90.write("        endif\n")
    ff90.write("      enddo\n")
    ff90.write("\n")
    ff90.write("      do kk = betrtracer_vars%id_trc_beg_pom, betrtracer_vars%id_trc_end_pom, nelm+1\n")
    ff90.write("        biogeo_state%c12state_vars%som2c_vr_col(c,j) = &\n")
    ff90.write("          catomw * tracerstate_vars%tracer_conc_mobile_col(c, j, kk-1+c_loc)\n")
    ff90.write("\n")
    ff90.write("        if(this%use_c13)then\n")
    ff90.write("          biogeo_state%c13state_vars%som2c_vr_col(c,j) =  &\n")
    ff90.write("            c13atomw * tracerstate_vars%tracer_conc_mobile_col(c, j, kk-1+c13_loc)\n")
    ff90.write("        endif\n")
    ff90.write("        if(this%use_c14)then\n")
    ff90.write("          biogeo_state%c14state_vars%som2c_vr_col(c,j) =  &\n")
    ff90.write("            c14atomw * tracerstate_vars%tracer_conc_mobile_col(c, j, kk-1+c14_loc)\n")
    ff90.write("        endif\n")
    ff90.write("      enddo\n")
    ff90.write("\n")
    ff90.write("      do kk = betrtracer_vars%id_trc_beg_dom, betrtracer_vars%id_trc_end_dom, nelm+1\n")
    ff90.write("        biogeo_state%c12state_vars%domc_vr_col(c,j) = &\n")
    ff90.write("          catomw * tracerstate_vars%tracer_conc_mobile_col(c, j, kk-1+c_loc)\n")
    ff90.write("\n")
    ff90.write("        if(this%use_c13)then\n")
    ff90.write("          biogeo_state%c13state_vars%domc_vr_col(c,j) =  &\n")
    ff90.write("            c13atomw * tracerstate_vars%tracer_conc_mobile_col(c, j, kk-1+c13_loc)\n")
    ff90.write("        endif\n")
    ff90.write("        if(this%use_c14)then\n")
    ff90.write("          biogeo_state%c14state_vars%domc_vr_col(c,j) =  &\n")
    ff90.write("            c14atomw * tracerstate_vars%tracer_conc_mobile_col(c, j, kk-1+c14_loc)\n")
    ff90.write("        endif\n")
    ff90.write("      enddo\n")
    ff90.write("\n")
    ff90.write("      do kk = betrtracer_vars%id_trc_beg_Bm+nelm, betrtracer_vars%id_trc_end_Bm, nelm\n")
    ff90.write("        biogeo_state%c12state_vars%som3c_vr_col(c,j) =  &\n")
    ff90.write("          catomw * tracerstate_vars%tracer_conc_mobile_col(c, j, kk-1+c_loc)\n")
    ff90.write("        if(this%use_c13)then\n")
    ff90.write("          biogeo_state%c13state_vars%som3c_vr_col(c,j) = &\n")
    ff90.write("            c13atomw * tracerstate_vars%tracer_conc_mobile_col(c, j, kk-1+c13_loc)\n")
    ff90.write("        endif\n")
    ff90.write("\n")
    ff90.write("        if(this%use_c14)then\n")
    ff90.write("          biogeo_state%c14state_vars%som3c_vr_col(c,j) =  &\n")
    ff90.write("            c14atomw * tracerstate_vars%tracer_conc_mobile_col(c, j, kk-1+c14_loc)\n")
    ff90.write("        endif\n")
    ff90.write("      enddo\n")
    ff90.write("    enddo\n")
    ff90.write("  enddo\n")
    ff90.write("  end subroutine retrieve_biostates\n")
    ff90.write("!------------------------------------------------------------------------------\n")
    ff90.write("  subroutine retrieve_output(this, c, j, nstates, ystates0, ystatesf, dtime, betrtracer_vars, tracerflux_vars,&\n")
    ff90.write("    tracerstate_vars, plant_soilbgc, biogeo_flux)\n")
    ff90.write("  !DESCRIPTION\n")
    ff90.write("  !retrieve flux and state variables after evolving the bgc calculation\n")
    ff90.write("  !\n")
    ff90.write("  !USES\n")
    ff90.write("  use BetrTracerType           , only : betrtracer_type\n")
    ff90.write("  use BeTR_biogeoFluxType      , only : betr_biogeo_flux_type\n")
    ff90.write("  use tracerfluxType           , only : tracerflux_type\n")
    ff90.write("  use tracerstatetype          , only : tracerstate_type\n")
    ff90.write("  use betr_ctrl                , only : betr_spinup_state\n")
    ff90.write("  use PlantSoilBGCMod          , only : plant_soilbgc_type\n")
    ff90.write("  use "+app_name+"PlantSoilBGCType    , only : "+app_name+"_plant_soilbgc_type\n")
    ff90.write("  use tracer_varcon            , only : catomw, natomw, patomw, fix_ip\n")
    ff90.write("  implicit none\n")
    ff90.write("  class("+app_name+"_bgc_reaction_type) , intent(inout)    :: this\n")
    ff90.write("  integer                              , intent(in) :: c, j\n")
    ff90.write("  integer                              , intent(in) :: nstates\n")
    ff90.write("  real(r8)                             , intent(in) :: ystates0(nstates)\n")
    ff90.write("  real(r8)                             , intent(inout) :: ystatesf(nstates)\n")
    ff90.write("  real(r8)                             , intent(in) :: dtime\n")
    ff90.write("  type(betrtracer_type)                , intent(in) :: betrtracer_vars    ! betr configuration information\n")
    ff90.write("  type(tracerstate_type)               , intent(inout) :: tracerstate_vars\n")
    ff90.write("  type(tracerflux_type)                , intent(inout) :: tracerflux_vars\n")
    ff90.write("  class(plant_soilbgc_type)            , intent(inout) :: plant_soilbgc\n")
    ff90.write("  type(betr_biogeo_flux_type)          , intent(inout) :: biogeo_flux\n")
    ff90.write("\n")
    ff90.write("  !local variables\n")
    ff90.write("  integer :: k, k1, k2, jj, p\n")
    ff90.write("  integer :: trcid\n")
    ff90.write("\n")
    ff90.write("  associate( &\n")
    ff90.write("    litr_beg =>  this%"+app_name+"_bgc_index%litr_beg  , &\n")
    ff90.write("    litr_end =>  this%"+app_name+"_bgc_index%litr_end  , &\n")
    ff90.write("    wood_beg =>  this%"+app_name+"_bgc_index%wood_beg  , &\n")
    ff90.write("    wood_end =>  this%"+app_name+"_bgc_index%wood_end  , &\n")
    ff90.write("    dom_beg =>  this%"+app_name+"_bgc_index%dom_beg    , &\n")
    ff90.write("    dom_end =>  this%"+app_name+"_bgc_index%dom_end    , &\n")
    ff90.write("    pom_beg =>  this%"+app_name+"_bgc_index%pom_beg    , &\n")
    ff90.write("    pom_end =>  this%"+app_name+"_bgc_index%pom_end    , &\n")
    ff90.write("    Bm_beg  =>  this%"+app_name+"_bgc_index%Bm_beg     , &\n")
    ff90.write("    Bm_end  =>  this%"+app_name+"_bgc_index%Bm_end     , &\n")
    ff90.write("    volatileid            => betrtracer_vars%volatileid      , &\n")
    ff90.write("    tracer_flx_netpro_vr  => tracerflux_vars%tracer_flx_netpro_vr_col     , & !\n")
    ff90.write("    tracer_flx_parchm_vr  => tracerflux_vars%tracer_flx_parchm_vr_col     , & !\n")
    ff90.write("    ngwmobile_tracers     => betrtracer_vars%ngwmobile_tracers              & !\n")
    ff90.write("  )\n")
    ff90.write("\n")
    ff90.write("  !tracer states\n")
    ff90.write("  tracerstate_vars%tracer_conc_mobile_col(c, j, betrtracer_vars%id_trc_beg_litr:betrtracer_vars%id_trc_end_litr) = &\n")
    ff90.write("     ystatesf(litr_beg:litr_end)\n")
    ff90.write("\n")
    ff90.write("  tracerstate_vars%tracer_conc_mobile_col(c, j, betrtracer_vars%id_trc_beg_wood:betrtracer_vars%id_trc_end_wood) = &\n")
    ff90.write("    ystatesf(wood_beg:wood_end)\n")
    ff90.write("\n")
    ff90.write("  tracerstate_vars%tracer_conc_mobile_col(c, j, betrtracer_vars%id_trc_beg_Bm:betrtracer_vars%id_trc_end_Bm) = &\n")
    ff90.write("    ystatesf(Bm_beg:Bm_end)\n")
    ff90.write("\n")
    ff90.write("  tracerstate_vars%tracer_conc_mobile_col(c, j, betrtracer_vars%id_trc_beg_dom:betrtracer_vars%id_trc_end_dom) = &\n")
    ff90.write("    ystatesf(dom_beg:dom_end)\n")
    ff90.write("\n")
    ff90.write("  tracerstate_vars%tracer_conc_mobile_col(c, j, betrtracer_vars%id_trc_beg_pom:betrtracer_vars%id_trc_end_pom) = &\n")
    ff90.write("    ystatesf(pom_beg:pom_end)\n")
    ff90.write("\n")
    ff90.write("  tracerstate_vars%tracer_conc_mobile_col(c, j, betrtracer_vars%id_trc_n2) = &\n")
    ff90.write("    ystatesf(this%"+app_name+"_bgc_index%lid_n2)\n")
    ff90.write("\n")
    ff90.write("  tracerstate_vars%tracer_conc_mobile_col(c, j, betrtracer_vars%id_trc_o2) = &\n")
    ff90.write("    ystatesf(this%"+app_name+"_bgc_index%lid_o2)\n")
    ff90.write("\n")
    ff90.write("  tracerstate_vars%tracer_conc_mobile_col(c, j, betrtracer_vars%id_trc_ar) = &\n")
    ff90.write("    ystatesf(this%"+app_name+"_bgc_index%lid_ar)\n")
    ff90.write("\n")
    ff90.write("  tracerstate_vars%tracer_conc_mobile_col(c, j, betrtracer_vars%id_trc_co2x) = &\n")
    ff90.write("    ystatesf(this%"+app_name+"_bgc_index%lid_co2)\n")
    ff90.write("\n")
    ff90.write("  if(this%use_c13)then\n")
    ff90.write("    tracerstate_vars%tracer_conc_mobile_col(c, j, betrtracer_vars%id_trc_c13_co2x) = &\n")
    ff90.write("      ystatesf(this%"+app_name+"_bgc_index%lid_c13_co2)\n")
    ff90.write("  endif\n")
    ff90.write("\n")
    ff90.write("  if(this%use_c14)then\n")
    ff90.write("    tracerstate_vars%tracer_conc_mobile_col(c, j, betrtracer_vars%id_trc_c14_co2x) = &\n")
    ff90.write("      ystatesf(this%"+app_name+"_bgc_index%lid_c14_co2)\n")
    ff90.write("  endif\n")
    ff90.write("\n")
    ff90.write("  tracerstate_vars%tracer_conc_mobile_col(c, j, betrtracer_vars%id_trc_ch4) = &\n")
    ff90.write("    ystatesf(this%"+app_name+"_bgc_index%lid_ch4)\n")
    ff90.write("\n")
    ff90.write("  !fluxes\n")
    ff90.write("  tracer_flx_parchm_vr(c,j,volatileid(betrtracer_vars%id_trc_o2) ) = &\n")
    ff90.write("     ystatesf(this%"+app_name+"_bgc_index%lid_o2_paere )  - &\n")
    ff90.write("     ystates0(this%"+app_name+"_bgc_index%lid_o2_paere)\n")
    ff90.write("\n")
    ff90.write("  if ( betr_spinup_state == 0 ) then\n")
    ff90.write("    tracer_flx_parchm_vr(c,j,volatileid(betrtracer_vars%id_trc_n2)  ) = &\n")
    ff90.write("      ystatesf(this%"+app_name+"_bgc_index%lid_n2_paere)  - &\n")
    ff90.write("      ystates0(this%"+app_name+"_bgc_index%lid_n2_paere)\n")
    ff90.write("\n")
    ff90.write("    tracer_flx_parchm_vr(c,j,volatileid(betrtracer_vars%id_trc_ar)  ) = &\n")
    ff90.write("      ystatesf(this%"+app_name+"_bgc_index%lid_ar_paere)  - &\n")
    ff90.write("      ystates0(this%"+app_name+"_bgc_index%lid_ar_paere)\n")
    ff90.write("\n")
    ff90.write("    tracer_flx_parchm_vr(c,j,volatileid(betrtracer_vars%id_trc_co2x)) = &\n")
    ff90.write("      ystatesf(this%"+app_name+"_bgc_index%lid_co2_paere)  - &\n")
    ff90.write("      ystates0(this%"+app_name+"_bgc_index%lid_co2_paere)\n")
    ff90.write("\n")
    ff90.write("    if(this%use_c13)then\n")
    ff90.write("      tracer_flx_parchm_vr(c,j,volatileid(betrtracer_vars%id_trc_c13_co2x)) = &\n")
    ff90.write("        ystatesf(this%"+app_name+"_bgc_index%lid_c13_co2_paere)  - &\n")
    ff90.write("        ystates0(this%"+app_name+"_bgc_index%lid_c13_co2_paere)\n")
    ff90.write("    endif\n")
    ff90.write("\n")
    ff90.write("    if(this%use_c14)then\n")
    ff90.write("      tracer_flx_parchm_vr(c,j,volatileid(betrtracer_vars%id_trc_c14_co2x)) = &\n")
    ff90.write("        ystatesf(this%"+app_name+"_bgc_index%lid_c14_co2_paere)  - &\n")
    ff90.write("        ystates0(this%"+app_name+"_bgc_index%lid_c14_co2_paere)\n")
    ff90.write("    endif\n")
    ff90.write("\n")
    ff90.write("    tracer_flx_parchm_vr(c,j,volatileid(betrtracer_vars%id_trc_ch4) ) = &\n")
    ff90.write("      ystatesf(this%"+app_name+"_bgc_index%lid_ch4_paere)  - &\n")
    ff90.write("      ystates0(this%"+app_name+"_bgc_index%lid_ch4_paere)\n")
    ff90.write("  endif\n")
    ff90.write("\n")
    ff90.write("  !get net production for om pools\n")
    ff90.write("  do k = 1, litr_end-litr_beg + 1\n")
    ff90.write("    k1 = litr_beg+k-1; k2 = betrtracer_vars%id_trc_beg_litr + k-1\n")
    ff90.write("    tracer_flx_netpro_vr(c,j,k2) =  ystatesf(k1) - ystates0(k1)\n")
    ff90.write("  enddo\n")
    ff90.write("  do k = 1, wood_end-wood_beg + 1\n")
    ff90.write("    k1 = wood_beg+k-1; k2 = betrtracer_vars%id_trc_beg_wood + k-1\n")
    ff90.write("    tracer_flx_netpro_vr(c,j,k2) =  ystatesf(k1) - ystates0(k1)\n")
    ff90.write("  enddo\n")
    ff90.write("  do k = 1, Bm_end-Bm_beg + 1\n")
    ff90.write("    k1 = Bm_beg+k-1; k2 = betrtracer_vars%id_trc_beg_Bm+ k-1\n")
    ff90.write("    tracer_flx_netpro_vr(c,j,k2) =  ystatesf(k1) - ystates0(k1)\n")
    ff90.write("  enddo\n")
    ff90.write("  do k = 1, dom_end-dom_beg + 1\n")
    ff90.write("    k1 = dom_beg+k-1; k2 = betrtracer_vars%id_trc_beg_dom+ k-1\n")
    ff90.write("    tracer_flx_netpro_vr(c,j,k2) =  ystatesf(k1) - ystates0(k1)\n")
    ff90.write("  enddo\n")
    ff90.write("  do k = 1, pom_end-pom_beg + 1\n")
    ff90.write("    k1 = pom_beg+k-1; k2 = betrtracer_vars%id_trc_beg_pom+ k-1\n")
    ff90.write("    tracer_flx_netpro_vr(c,j,k2) =  ystatesf(k1) - ystates0(k1)\n")
    ff90.write("  enddo\n")
    ff90.write("  tracer_flx_netpro_vr(c,j,betrtracer_vars%id_trc_n2) = &\n")
    ff90.write("    ystatesf(this%"+app_name+"_bgc_index%lid_n2) - &\n")
    ff90.write("    ystates0(this%"+app_name+"_bgc_index%lid_n2)\n")
    ff90.write("\n")
    ff90.write("  tracer_flx_netpro_vr(c,j,betrtracer_vars%id_trc_co2x ) = &\n")
    ff90.write("    ystatesf(this%"+app_name+"_bgc_index%lid_co2) - &\n")
    ff90.write("    ystates0(this%"+app_name+"_bgc_index%lid_co2)\n")
    ff90.write("\n")
    ff90.write("  if(this%use_c13)then\n")
    ff90.write("    tracer_flx_netpro_vr(c,j,betrtracer_vars%id_trc_c13_co2x ) = &\n")
    ff90.write("      ystatesf(this%"+app_name+"_bgc_index%lid_c13_co2) - &\n")
    ff90.write("      ystates0(this%"+app_name+"_bgc_index%lid_c13_co2)\n")
    ff90.write("  endif\n")
    ff90.write("\n")
    ff90.write("  if(this%use_c14)then\n")
    ff90.write("    tracer_flx_netpro_vr(c,j,betrtracer_vars%id_trc_c14_co2x ) = &\n")
    ff90.write("      ystatesf(this%"+app_name+"_bgc_index%lid_c14_co2) - &\n")
    ff90.write("      ystates0(this%"+app_name+"_bgc_index%lid_c14_co2)\n")
    ff90.write("  endif\n")
    ff90.write("\n")
    ff90.write("  tracer_flx_netpro_vr(c,j,betrtracer_vars%id_trc_o2   ) = &\n")
    ff90.write("    ystatesf(this%"+app_name+"_bgc_index%lid_o2) - &\n")
    ff90.write("    ystates0(this%"+app_name+"_bgc_index%lid_o2)\n")
    ff90.write("\n")
    ff90.write("  tracer_flx_netpro_vr(c,j,betrtracer_vars%id_trc_ch4  ) = &\n")
    ff90.write("    ystatesf(this%"+app_name+"_bgc_index%lid_ch4) - &\n")
    ff90.write("    ystates0(this%"+app_name+"_bgc_index%lid_ch4)\n")
    ff90.write("\n")
    ff90.write("  tracer_flx_netpro_vr(c,j,betrtracer_vars%id_trc_ar) = &\n")
    ff90.write("    ystatesf(this%"+app_name+"_bgc_index%lid_ar) - &\n")
    ff90.write("    ystates0(this%"+app_name+"_bgc_index%lid_ar)\n")
    ff90.write("\n")
    ff90.write("  !get net production for om pools\n")
    ff90.write("  do k = 1, litr_end-litr_beg + 1\n")
    ff90.write("    k1 = litr_beg+k-1; k2 = betrtracer_vars%id_trc_beg_litr + k-1\n")
    ff90.write("    tracer_flx_netpro_vr(c,j,k2) =  ystatesf(k1) - ystates0(k1)\n")
    ff90.write("  enddo\n")
    ff90.write("\n")
    ff90.write("  do k = 1, wood_end-wood_beg + 1\n")
    ff90.write("    k1 = wood_beg+k-1; k2 = betrtracer_vars%id_trc_beg_wood + k-1\n")
    ff90.write("    tracer_flx_netpro_vr(c,j,k2) =  ystatesf(k1) - ystates0(k1)\n")
    ff90.write("  enddo\n")
    ff90.write("\n")
    ff90.write("  do k = 1, Bm_end-Bm_beg + 1\n")
    ff90.write("    k1 = Bm_beg+k-1; k2 = betrtracer_vars%id_trc_beg_Bm+ k-1\n")
    ff90.write("    tracer_flx_netpro_vr(c,j,k2) =  ystatesf(k1) - ystates0(k1)\n")
    ff90.write("  enddo\n")
    ff90.write("\n")
    ff90.write("  biogeo_flux%c12flux_vars%hr_vr_col(c,j) = &\n")
    ff90.write("    (ystatesf(this%"+app_name+"_bgc_index%lid_co2_hr) - &\n")
    ff90.write("    ystates0(this%"+app_name+"_bgc_index%lid_co2_hr))*catomw/dtime\n")
    ff90.write("  end associate\n")
    ff90.write("  end subroutine retrieve_output\n")
    ff90.write("!------------------------------------------------------------------------------\n")
    ff90.write("  subroutine set_bgc_forc(this, bounds, col, lbj, ubj, jtops, num_soilc, filter_soilc, &\n")
    ff90.write("    biophysforc, plant_soilbgc, betrtracer_vars, tracercoeff_vars, tracerstate_vars, betr_status)\n")
    ff90.write("  !\n")
    ff90.write("  !DESCRIPTION\n")
    ff90.write("  use BeTR_biogeophysInputType , only : betr_biogeophys_input_type\n")
    ff90.write("  use PlantSoilBGCMod          , only : plant_soilbgc_type\n")
    ff90.write("  use tracerstatetype          , only : tracerstate_type\n")
    ff90.write("  use betr_decompMod           , only : betr_bounds_type\n")
    ff90.write("  use tracercoeffType          , only : tracercoeff_type\n")
    ff90.write("  use betr_columnType          , only : betr_column_type\n")
    ff90.write("  use BetrTracerType           , only : betrtracer_type\n")
    ff90.write("  use "+app_name+"PlantSoilBGCType    , only : "+app_name+"_plant_soilbgc_type\n")
    ff90.write("  use MathfuncMod              , only : fpmax\n")
    ff90.write("  use betr_varcon              , only : grav => bgrav\n")
    ff90.write("  implicit none\n")
    ff90.write("  class("+app_name+"_bgc_reaction_type) , intent(inout) :: this    !\n")
    ff90.write("  type(bounds_type)                    , intent(in) :: bounds     ! bounds\n")
    ff90.write("  type(betr_column_type)               , intent(in) :: col\n")
    ff90.write("  integer                              , intent(in) :: jtops(bounds%begc: ) ! top index of each column\n")
    ff90.write("  integer                              , intent(in) :: lbj, ubj       ! lower and upper bounds, make sure they are > 0\n")
    ff90.write("  integer                              , intent(in) :: num_soilc       ! number of columns in column filter\n")
    ff90.write("  integer                              , intent(in) :: filter_soilc(:) ! column filter\n")
    ff90.write("  type(betr_biogeophys_input_type)     , intent(in) :: biophysforc\n")
    ff90.write("  class(plant_soilbgc_type)            , intent(in) :: plant_soilbgc\n")
    ff90.write("  type(betrtracer_type)                , intent(in) :: betrtracer_vars     ! betr configuration information\n")
    ff90.write("  type(tracerstate_type)               , intent(in) :: tracerstate_vars\n")
    ff90.write("  type(tracercoeff_type)               , intent(in) :: tracercoeff_vars\n")
    ff90.write("  type(betr_status_type)               , intent(out)   :: betr_status\n")
    ff90.write("\n")
    ff90.write("  integer :: j, fc, c\n")
    ff90.write("  integer :: k1, k2\n")
    ff90.write("  real(r8), parameter :: tiny_cval =1.e-16_r8\n")
    ff90.write("\n")
    ff90.write("  associate( &\n")
    ff90.write("    litr_beg =>  this%"+app_name+"_bgc_index%litr_beg  , &\n")
    ff90.write("    litr_end =>  this%"+app_name+"_bgc_index%litr_end  , &\n")
    ff90.write("    wood_beg =>  this%"+app_name+"_bgc_index%wood_beg  , &\n")
    ff90.write("    wood_end =>  this%"+app_name+"_bgc_index%wood_end  , &\n")
    ff90.write("    dom_beg =>  this%"+app_name+"_bgc_index%dom_beg    , &\n")
    ff90.write("    dom_end =>  this%"+app_name+"_bgc_index%dom_end    , &\n")
    ff90.write("    pom_beg =>  this%"+app_name+"_bgc_index%pom_beg    , &\n")
    ff90.write("    pom_end =>  this%"+app_name+"_bgc_index%pom_end    , &\n")
    ff90.write("    Bm_beg  =>  this%"+app_name+"_bgc_index%Bm_beg     , &\n")
    ff90.write("    Bm_end  =>  this%"+app_name+"_bgc_index%Bm_end       &\n")
    ff90.write("  )\n")
    ff90.write("\n")
    ff90.write("  call betr_status%reset()\n")
    ff90.write("  SHR_ASSERT_ALL((ubound(jtops) == (/bounds%endc/)), errMsg(mod_filename,__LINE__),betr_status)\n")
    ff90.write("\n")
    ff90.write("  do j = lbj, ubj\n")
    ff90.write("    do fc = 1, num_soilc\n")
    ff90.write("      c = filter_soilc(fc)\n")
    ff90.write("      if(j<jtops(c))cycle\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%plant_ntypes = this%nactpft\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%ystates(:) = 0._r8\n")
    ff90.write("\n")
    ff90.write("      !litter\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%ystates(litr_beg:litr_end)= &\n")
    ff90.write("        tracerstate_vars%tracer_conc_mobile_col(c, j, betrtracer_vars%id_trc_beg_litr:betrtracer_vars%id_trc_end_litr)\n")
    ff90.write("\n")
    ff90.write("      !wood\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%ystates(wood_beg:wood_end)= &\n")
    ff90.write("        tracerstate_vars%tracer_conc_mobile_col(c, j, betrtracer_vars%id_trc_beg_wood:betrtracer_vars%id_trc_end_wood)\n")
    ff90.write("\n")
    ff90.write("      !dom\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%ystates(dom_beg:dom_end)= &\n")
    ff90.write("      tracerstate_vars%tracer_conc_mobile_col(c, j, betrtracer_vars%id_trc_beg_dom:betrtracer_vars%id_trc_end_dom)\n")
    ff90.write("      if(this%"+app_name+"_forc(c,j)%ystates(dom_beg)<=tiny_cval)this%"+app_name+"_forc(c,j)%ystates(dom_beg:dom_end)=0._r8\n")
    ff90.write("\n")
    ff90.write("      !pom\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%ystates(pom_beg:pom_end)= &\n")
    ff90.write("        tracerstate_vars%tracer_conc_mobile_col(c, j, betrtracer_vars%id_trc_beg_pom:betrtracer_vars%id_trc_end_pom)\n")
    ff90.write("      if(this%"+app_name+"_forc(c,j)%ystates(pom_beg)<=tiny_cval)this%"+app_name+"_forc(c,j)%ystates(pom_beg:pom_end)=0._r8\n")
    ff90.write("\n")
    ff90.write("      !microbial biomass\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%ystates(Bm_beg:Bm_end)= &\n")
    ff90.write("        tracerstate_vars%tracer_conc_mobile_col(c, j, betrtracer_vars%id_trc_beg_Bm:betrtracer_vars%id_trc_end_Bm)\n")
    ff90.write("      if(this%"+app_name+"_forc(c,j)%ystates(Bm_beg)<=tiny_cval)this%"+app_name+"_forc(c,j)%ystates(Bm_beg:Bm_end)=0._r8\n")
    ff90.write("\n")
    ff90.write("      !non-soluble phase of mineral p\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%ystates(this%"+app_name+"_bgc_index%lid_n2) = &\n")
    ff90.write("         fpmax(tracerstate_vars%tracer_conc_mobile_col(c, j, betrtracer_vars%id_trc_n2))\n")
    ff90.write("\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%ystates(this%"+app_name+"_bgc_index%lid_o2) = &\n")
    ff90.write("        fpmax(tracerstate_vars%tracer_conc_mobile_col(c, j, betrtracer_vars%id_trc_o2))\n")
    ff90.write("\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%ystates(this%"+app_name+"_bgc_index%lid_ar) = &\n")
    ff90.write("        fpmax(tracerstate_vars%tracer_conc_mobile_col(c, j, betrtracer_vars%id_trc_ar))\n")
    ff90.write("\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%ystates(this%"+app_name+"_bgc_index%lid_co2)= &\n")
    ff90.write("        fpmax(tracerstate_vars%tracer_conc_mobile_col(c, j, betrtracer_vars%id_trc_co2x))\n")
    ff90.write("\n")
    ff90.write("      if(this%use_c13)then\n")
    ff90.write("        this%"+app_name+"_forc(c,j)%ystates(this%"+app_name+"_bgc_index%lid_c13_co2)= &\n")
    ff90.write("          fpmax(tracerstate_vars%tracer_conc_mobile_col(c, j, betrtracer_vars%id_trc_c13_co2x))\n")
    ff90.write("      endif\n")
    ff90.write("      if(this%use_c14)then\n")
    ff90.write("        this%"+app_name+"_forc(c,j)%ystates(this%"+app_name+"_bgc_index%lid_c14_co2)= &\n")
    ff90.write("          fpmax(tracerstate_vars%tracer_conc_mobile_col(c, j, betrtracer_vars%id_trc_c14_co2x))\n")
    ff90.write("      endif\n")
    ff90.write("\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%ystates(this%"+app_name+"_bgc_index%lid_ch4)= &\n")
    ff90.write("        fpmax(tracerstate_vars%tracer_conc_mobile_col(c, j, betrtracer_vars%id_trc_ch4))\n")
    ff90.write("\n")
    ff90.write("      !input\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%cflx_input_litr_met = biophysforc%c12flx%cflx_input_litr_met_vr_col(c,j)\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%cflx_input_litr_cel = biophysforc%c12flx%cflx_input_litr_cel_vr_col(c,j)\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%cflx_input_litr_lig = biophysforc%c12flx%cflx_input_litr_lig_vr_col(c,j)\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%cflx_input_litr_cwd = biophysforc%c12flx%cflx_input_litr_cwd_vr_col(c,j)\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%cflx_input_litr_lwd = biophysforc%c12flx%cflx_input_litr_lwd_vr_col(c,j)\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%cflx_input_litr_fwd = biophysforc%c12flx%cflx_input_litr_fwd_vr_col(c,j)\n")
    ff90.write("\n")
    ff90.write("      !environmental variables\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%temp   = biophysforc%t_soisno_col(c,j)            !temperature\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%depz   = col%z(c,j)            !depth of the soil\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%dzsoi  = col%dz(c,j)            !soil thickness\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%sucsat  = biophysforc%sucsat_col(c,j)   ! Input:  [real(r8) (:,:)] minimum soil suction [mm]\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%soilpsi = max(biophysforc%smp_l_col(c,j)*grav*1.e-6_r8,-15._r8)    ! Input:  [real(r8) (:,:)] soilwater pontential in each soil layer [MPa]\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%bsw = biophysforc%bsw_col(c,j)\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%bd   = biophysforc%bd_col(c,j)              !bulk density\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%pct_sand = biophysforc%cellsand_col(c,j)\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%pct_clay = biophysforc%cellclay_col(c,j)\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%h2osoi_vol = biophysforc%h2osoi_vol_col(c,j)\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%h2osoi_liq = biophysforc%h2osoi_liq_col(c,j)\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%air_vol = biophysforc%air_vol_col(c,j)\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%finundated = biophysforc%finundated_col(c)\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%watsat = biophysforc%watsat_col(c,j)\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%watfc = biophysforc%watfc_col(c,j)\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%cellorg = biophysforc%cellorg_col(c,j)\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%pH = biophysforc%soil_pH(c,j)\n")
    ff90.write("\n")
    ff90.write("      !conductivity for plant-aided gas transport\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%aren_cond_n2 = &\n")
    ff90.write("        tracercoeff_vars%aere_cond_col(c,betrtracer_vars%volatilegroupid(betrtracer_vars%id_trc_n2)) * &\n")
    ff90.write("        tracercoeff_vars%scal_aere_cond_col(c,betrtracer_vars%volatilegroupid(betrtracer_vars%id_trc_n2))\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%aren_cond_o2 = &\n")
    ff90.write("        tracercoeff_vars%aere_cond_col(c,betrtracer_vars%volatilegroupid(betrtracer_vars%id_trc_o2)) * &\n")
    ff90.write("        tracercoeff_vars%scal_aere_cond_col(c,betrtracer_vars%volatilegroupid(betrtracer_vars%id_trc_o2))\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%aren_cond_co2 = &\n")
    ff90.write("        tracercoeff_vars%aere_cond_col(c,betrtracer_vars%volatilegroupid(betrtracer_vars%id_trc_co2x)) * &\n")
    ff90.write("        tracercoeff_vars%scal_aere_cond_col(c,betrtracer_vars%volatilegroupid(betrtracer_vars%id_trc_co2x))\n")
    ff90.write("      if(this%use_c13)then\n")
    ff90.write("        this%"+app_name+"_forc(c,j)%aren_cond_co2_c13 = &\n")
    ff90.write("          tracercoeff_vars%aere_cond_col(c,betrtracer_vars%volatilegroupid(betrtracer_vars%id_trc_c13_co2x)) * &\n")
    ff90.write("          tracercoeff_vars%scal_aere_cond_col(c,betrtracer_vars%volatilegroupid(betrtracer_vars%id_trc_c13_co2x))\n")
    ff90.write("      endif\n")
    ff90.write("      if(this%use_c14)then\n")
    ff90.write("        this%"+app_name+"_forc(c,j)%aren_cond_co2_c14 = &\n")
    ff90.write("          tracercoeff_vars%aere_cond_col(c,betrtracer_vars%volatilegroupid(betrtracer_vars%id_trc_c14_co2x)) * &\n")
    ff90.write("          tracercoeff_vars%scal_aere_cond_col(c,betrtracer_vars%volatilegroupid(betrtracer_vars%id_trc_c14_co2x))\n")
    ff90.write("      endif\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%aren_cond_ar = &\n")
    ff90.write("        tracercoeff_vars%aere_cond_col(c,betrtracer_vars%volatilegroupid(betrtracer_vars%id_trc_ar)) * &\n")
    ff90.write("        tracercoeff_vars%scal_aere_cond_col(c,betrtracer_vars%volatilegroupid(betrtracer_vars%id_trc_ar))\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%aren_cond_ch4 = &\n")
    ff90.write("        tracercoeff_vars%aere_cond_col(c,betrtracer_vars%volatilegroupid(betrtracer_vars%id_trc_ch4)) * &\n")
    ff90.write("        tracercoeff_vars%scal_aere_cond_col(c,betrtracer_vars%volatilegroupid(betrtracer_vars%id_trc_ch4))\n")
    ff90.write("      !phase conversion parameter\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%ch4_g2b = &\n")
    ff90.write("        tracercoeff_vars%gas2bulkcef_mobile_col(c,j,betrtracer_vars%volatilegroupid(betrtracer_vars%id_trc_ch4))\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%co2_g2b = &\n")
    ff90.write("        tracercoeff_vars%gas2bulkcef_mobile_col(c,j,betrtracer_vars%volatilegroupid(betrtracer_vars%id_trc_co2x))\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%o2_g2b = &\n")
    ff90.write("        tracercoeff_vars%gas2bulkcef_mobile_col(c,j,betrtracer_vars%volatilegroupid(betrtracer_vars%id_trc_o2))\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%n2_g2b = &\n")
    ff90.write("        tracercoeff_vars%gas2bulkcef_mobile_col(c,j,betrtracer_vars%volatilegroupid(betrtracer_vars%id_trc_n2))\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%ar_g2b = &\n")
    ff90.write("        tracercoeff_vars%gas2bulkcef_mobile_col(c,j,betrtracer_vars%volatilegroupid(betrtracer_vars%id_trc_ar))\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%o2_w2b = &\n")
    ff90.write("        tracercoeff_vars%aqu2bulkcef_mobile_col(c,j,betrtracer_vars%groupid(betrtracer_vars%id_trc_o2))\n")
    ff90.write("\n")
    ff90.write("      !atmospheric pressure (mol/m3) for gas ventilation.\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%conc_atm_n2 = &\n")
    ff90.write("        tracerstate_vars%tracer_conc_atm_col(c,betrtracer_vars%volatileid(betrtracer_vars%id_trc_n2))\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%conc_atm_o2 = &\n")
    ff90.write("        tracerstate_vars%tracer_conc_atm_col(c,betrtracer_vars%volatileid(betrtracer_vars%id_trc_o2))\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%conc_atm_ar = &\n")
    ff90.write("        tracerstate_vars%tracer_conc_atm_col(c,betrtracer_vars%volatileid(betrtracer_vars%id_trc_ar))\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%conc_atm_co2 = &\n")
    ff90.write("        tracerstate_vars%tracer_conc_atm_col(c,betrtracer_vars%volatileid(betrtracer_vars%id_trc_co2x))\n")
    ff90.write("      if(this%use_c13)then\n")
    ff90.write("        this%"+app_name+"_forc(c,j)%conc_atm_co2_c13 = &\n")
    ff90.write("          tracerstate_vars%tracer_conc_atm_col(c,betrtracer_vars%volatileid(betrtracer_vars%id_trc_c13_co2x))\n")
    ff90.write("      endif\n")
    ff90.write("      if(this%use_c14)then\n")
    ff90.write("        this%"+app_name+"_forc(c,j)%conc_atm_co2_c14 = &\n")
    ff90.write("          tracerstate_vars%tracer_conc_atm_col(c,betrtracer_vars%volatileid(betrtracer_vars%id_trc_c14_co2x))\n")
    ff90.write("      endif\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%conc_atm_ch4 = &\n")
    ff90.write("        tracerstate_vars%tracer_conc_atm_col(c,betrtracer_vars%volatileid(betrtracer_vars%id_trc_ch4))\n")
    ff90.write("\n")
    ff90.write("      this%"+app_name+"_forc(c,j)%soilorder = biophysforc%isoilorder(c)\n")
    ff90.write("    enddo\n")
    ff90.write("  enddo\n")
    ff90.write("  end associate\n")
    ff90.write("  end subroutine set_bgc_forc\n")
    ff90.write("!------------------------------------------------------------------------------\n")
    ff90.write("  subroutine update_sorpphase_coeff(this, bounds, col, lbj, ubj, jtops, num_soilc, filter_soilc, &\n")
    ff90.write("    betrtracer_vars, tracerstate_vars, tracercoeff_vars)\n")
    ff90.write("  !\n")
    ff90.write("  !DESCRIPTION\n")
    ff90.write("  !update sorption related phase conversion parameter\n")
    ff90.write("  !in this formulation, the amount sorption surface is assumed to scale linearly with moisture\n")
    ff90.write("  !content. Microbes are always assumed in sufficiently moist status, though the activity could be\n")
    ff90.write("  !smaller\n")
    ff90.write("  use tracerstatetype          , only : tracerstate_type\n")
    ff90.write("  use betr_decompMod           , only : betr_bounds_type\n")
    ff90.write("  use tracercoeffType          , only : tracercoeff_type\n")
    ff90.write("  use betr_columnType          , only : betr_column_type\n")
    ff90.write("  use BetrTracerType           , only : betrtracer_type\n")
    ff90.write("  implicit none\n")
    ff90.write("  class("+app_name+"_bgc_reaction_type) , intent(inout) :: this      !\n")
    ff90.write("  type(bounds_type)                    , intent(in) :: bounds        ! bounds\n")
    ff90.write("  type(betr_column_type)               , intent(in) :: col\n")
    ff90.write("  integer                              , intent(in) :: jtops(bounds%begc: ) ! top index of each column\n")
    ff90.write("  integer                              , intent(in) :: lbj, ubj     ! lower and upper bounds, make sure they are > 0\n")
    ff90.write("  integer                              , intent(in) :: num_soilc       ! number of columns in column filter\n")
    ff90.write("  integer                              , intent(in) :: filter_soilc(:) ! column filter\n")
    ff90.write("  type(betrtracer_type)                , intent(in) :: betrtracer_vars    ! betr configuration information\n")
    ff90.write("  type(tracerstate_type)               , intent(in) :: tracerstate_vars\n")
    ff90.write("  type(tracercoeff_type)               , intent(inout) :: tracercoeff_vars\n")
    ff90.write("\n")
    ff90.write("  real(r8) :: KM_CM, Msurf, KM_EM, BMT\n")
    ff90.write("  real(r8) :: denorm1, denorm0, denorm2,beta\n")
    ff90.write("  integer :: c_l, j\n")
    ff90.write("\n")
    ff90.write("  associate(                                                           &\n")
    ff90.write("    aqu2bulkcef_mobile   => tracercoeff_vars%aqu2bulkcef_mobile_col  , & !Output:[real(r8)(:,:)], phase conversion coeff\n")
    ff90.write("    id_trc_dom           => betrtracer_vars%id_trc_dom               , &\n")
    ff90.write("    trcid_Bm             => betrtracer_vars%id_trc_beg_Bm            , &\n")
    ff90.write("    trcid_dom            => betrtracer_vars%id_trc_beg_dom           , &\n")
    ff90.write("    trcid_pom            => betrtracer_vars%id_trc_beg_pom           , &\n")
    ff90.write("    id_trc_end_dom       => betrtracer_vars%id_trc_end_dom           , &\n")
    ff90.write("    tracer_conc_mobile   => tracerstate_vars%tracer_conc_mobile_col  , &\n")
    ff90.write("  !  Kaff_CM              => "+app_name+"_para%Kaff_CM                , &\n")
    ff90.write("  ! Kaff_EM              => "+app_name+"_para%Kaff_EM                , &\n")
    ff90.write("  !  Kaff_BC              => "+app_name+"_para%Kaff_BC                , &\n")
    ff90.write("  !  alpha_B2E            => "+app_name+"_para%alpha_B2E              , &\n")
    ff90.write("  !  alpha_B2T            => "+app_name+"_para%alpha_B2T              , &\n")
    ff90.write("    nelms                =>  this%"+app_name+"_bgc_index%nelms         &\n")
    ff90.write("  )\n")
    ff90.write("\n")
    ff90.write("  c_l=1\n")
    ff90.write("  do j = 1, ubj\n")
    ff90.write("    !KM_CM=aqu2bulkcef_mobile(c_l,j,id_trc_dom)*this%"+app_name+"_forc(c_l,j)%KM_OM_ref*Kaff_CM\n")
    ff90.write("    !BMT=(tracer_conc_mobile(c_l,j,trcid_Bm)+tracer_conc_mobile(c_l,j,trcid_Bm+nelms))*alpha_B2T\n")
    ff90.write("    !Msurf=this%"+app_name+"_forc(c_l,j)%Msurf_OM-tracer_conc_mobile(c_l,j,trcid_pom)\n")
    ff90.write("    !denorm0=1._r8+Msurf/KM_CM+BMT/Kaff_BC\n")
    ff90.write("    !denorm1=denorm0+tracer_conc_mobile(c_l,j,trcid_dom)/KM_CM\n")
    ff90.write("    !denorm2=denorm0+tracer_conc_mobile(c_l,j,trcid_dom)/Kaff_BC\n")
    ff90.write("    !beta=1._r8/(1._r8-Msurf/KM_CM/denorm1-BMT/Kaff_BC/denorm2)\n")
    ff90.write("    !aqu2bulkcef_mobile(c_l,j,id_trc_dom) = aqu2bulkcef_mobile(c_l,j,id_trc_dom)*beta\n")
    ff90.write("  enddo\n")
    ff90.write("  end associate\n")
    ff90.write("  end subroutine update_sorpphase_coeff\n")
    ff90.write("end module "+app_name+"BGCReactionsType\n")
    ff90.close()
    print "create file "+sfarm_dir+'/'+app_name+'/'+app_name+'Nlayer/'+app_name+"PlantSoilBGCType.F90"
    ff90=open(sfarm_dir+'/'+app_name+'/'+app_name+'Nlayer/'+app_name+"PlantSoilBGCType.F90","w")
    ff90.write("module "+app_name+"PlantSoilBGCType\n")
    ff90.write("  !\n")
    ff90.write("  !DESCRIPTION\n")
    ff90.write("  ! mock interface for plant soil bgc coupling\n")
    ff90.write('#include "bshr_assert.h"\n')
    ff90.write("  !USES\n")
    ff90.write("  use PlantSoilBGCMod , only : plant_soilbgc_type\n")
    ff90.write("  use betr_decompMod  , only : bounds_type => betr_bounds_type\n")
    ff90.write("  use bshr_log_mod    , only : errMsg => shr_log_errMsg\n")
    ff90.write("  implicit none\n")
    ff90.write("\n")
    ff90.write("  private\n")
    ff90.write("  character(len=*), private, parameter :: mod_filename = &\n")
    ff90.write("    __FILE__\n")
    ff90.write("  public :: "+app_name+"_plant_soilbgc_type\n")
    ff90.write("\n")
    ff90.write("  type, extends(plant_soilbgc_type) :: &\n")
    ff90.write("    "+app_name+"_plant_soilbgc_type\n")
    ff90.write("    private\n")
    ff90.write("  contains\n")
    ff90.write("    procedure :: Init_plant_soilbgc\n")
    ff90.write("    procedure :: plant_soilbgc_summary\n")
    ff90.write("    procedure :: integrate_vr_flux\n")
    ff90.write("    procedure :: lsm_betr_plant_soilbgc_recv\n")
    ff90.write("    procedure :: lsm_betr_plant_soilbgc_send\n")
    ff90.write("  end type "+app_name+"_plant_soilbgc_type\n")
    ff90.write("\n")
    ff90.write("  interface "+app_name+"_plant_soilbgc_type\n")
    ff90.write("    module procedure constructor\n")
    ff90.write("  end interface "+app_name+"_plant_soilbgc_type\n")
    ff90.write("\n")
    ff90.write("  contains\n")
    ff90.write("!-------------------------------------------------------------------------------\n")
    ff90.write("  type("+app_name+"_plant_soilbgc_type) function constructor()\n")
    ff90.write("  !\n")
    ff90.write("  ! !DESCRIPTION:\n")
    ff90.write("  ! create an object of type "+app_name+"_plant_soilbgc_type.\n")
    ff90.write("  ! Right now it is purposely empty\n")
    ff90.write("  type("+app_name+"_plant_soilbgc_type), allocatable :: plants\n")
    ff90.write("  allocate(plants)\n")
    ff90.write("  constructor = plants\n")
    ff90.write("  end function constructor\n")
    ff90.write("!-------------------------------------------------------------------------------\n")
    ff90.write("  subroutine Init_plant_soilbgc(this, bounds, lbj, ubj, namelist_buffer)\n")
    ff90.write("  !\n")
    ff90.write("  ! !DESCRIPTION:\n")
    ff90.write("  ! template for init_betrbgc\n")
    ff90.write("  !\n")
    ff90.write("  ! !USES:\n")
    ff90.write("  use gbetrType      , only : gbetr_type\n")
    ff90.write("  implicit none\n")
    ff90.write("  ! !ARGUMENTS:\n")
    ff90.write("  class("+app_name+"_plant_soilbgc_type) , intent(inout) :: this\n")
    ff90.write("  type(bounds_type)                  , intent(in) :: bounds\n")
    ff90.write("  integer                            , intent(in) :: lbj, ubj\n")
    ff90.write("  character(len=*)                   , intent(in) :: namelist_buffer\n")
    ff90.write("\n")
    ff90.write("  ! remove compiler warnings for unused dummy args\n")
    ff90.write("  if (this%dummy_compiler_warning) continue\n")
    ff90.write("  if (bounds%begc > 0)             continue\n")
    ff90.write("  if (lbj > 0)                     continue\n")
    ff90.write("  if (ubj > 0)                     continue\n")
    ff90.write("\n")
    ff90.write("  end subroutine Init_plant_soilbgc\n")
    ff90.write("!----------------------------------------------------------------------\n")
    ff90.write("  subroutine plant_soilbgc_summary(this,bounds, lbj, ubj, pft, numf, &\n")
    ff90.write("    filter, dtime, dz, betrtracer_vars, tracerflux_vars, biogeo_flux, betr_status)\n")
    ff90.write("  !DESCRIPTION\n")
    ff90.write("  !summarize bgc coupling flux variables\n")
    ff90.write("  ! !USES:\n")
    ff90.write("  use BeTRTracerType , only : BeTRtracer_type\n")
    ff90.write("  use tracerfluxType , only : tracerflux_type\n")
    ff90.write("  use bshr_kind_mod  , only : r8 => shr_kind_r8\n")
    ff90.write("  use BetrStatusType , only : betr_status_type\n")
    ff90.write("  use BeTR_PatchType , only : betr_patch_type\n")
    ff90.write("  use BeTR_biogeoFluxType  , only : betr_biogeo_flux_type\n")
    ff90.write("  implicit none\n")
    ff90.write("  ! !ARGUMENTS:\n")
    ff90.write("  class("+app_name+"_plant_soilbgc_type) , intent(inout) :: this\n")
    ff90.write("  type(bounds_type)                  , intent(in) :: bounds\n")
    ff90.write("  integer                            , intent(in) :: lbj, ubj\n")
    ff90.write("  type(betr_patch_type)              , intent(in) :: pft\n")
    ff90.write("  integer                            , intent(in) :: numf\n")
    ff90.write("  integer                            , intent(in) :: filter(:)\n")
    ff90.write("  real(r8)                           , intent(in) :: dtime\n")
    ff90.write("  real(r8)                           , intent(in) :: dz(bounds%begc: ,1: )\n")
    ff90.write("  type(BeTRtracer_type )             , intent(in) :: betrtracer_vars\n")
    ff90.write("  type(tracerflux_type)              , intent(in) :: tracerflux_vars\n")
    ff90.write("  type(betr_biogeo_flux_type)        , intent(inout) :: biogeo_flux\n")
    ff90.write("  type(betr_status_type)             , intent(out):: betr_status\n")
    ff90.write("\n")
    ff90.write("  call betr_status%reset()\n")
    ff90.write("  SHR_ASSERT_ALL((ubound(dz)==(/bounds%endc,ubj/)), errMsg(mod_filename,__LINE__), betr_status)\n")
    ff90.write("\n")
    ff90.write("  ! remove compiler warnings for unused dummy args\n")
    ff90.write("  if (this%dummy_compiler_warning)                       continue\n")
    ff90.write("  if (bounds%begc > 0)                                   continue\n")
    ff90.write("  if (numf > 0)                                          continue\n")
    ff90.write("  if (size(filter) > 0)                                  continue\n")
    ff90.write("  if (lbj > 0)                                           continue\n")
    ff90.write("  if (ubj > 0)                                           continue\n")
    ff90.write("  if (size(dz) > 0)                                      continue\n")
    ff90.write("  if (len(betrtracer_vars%betr_simname) > 0)             continue\n")
    ff90.write("  if (size(tracerflux_vars%tracer_flx_top_soil_col) > 0) continue\n")
    ff90.write("\n")
    ff90.write("  end subroutine plant_soilbgc_summary\n")
    ff90.write("!----------------------------------------------------------------------\n")
    ff90.write("  subroutine integrate_vr_flux(this, bounds, numf, filter)\n")

    ff90.write("  implicit none\n")
    ff90.write("  ! !ARGUMENTS:\n")
    ff90.write("  class("+app_name+"_plant_soilbgc_type) , intent(inout) :: this\n")
    ff90.write("  type(bounds_type)                  , intent(in) :: bounds\n")
    ff90.write("  integer                            , intent(in) :: numf\n")
    ff90.write("  integer                            , intent(in) :: filter(:)\n")
    ff90.write("\n")
    ff90.write("  ! remove compiler warnings for unused dummy args\n")
    ff90.write("  if (this%dummy_compiler_warning) continue\n")
    ff90.write("  if (bounds%begc > 0)             continue\n")
    ff90.write("  if (numf > 0)                    continue\n")
    ff90.write("  if (size(filter) > 0)            continue\n")
    ff90.write("\n")
    ff90.write("  end subroutine integrate_vr_flux\n")
    ff90.write("!----------------------------------------------------------------------\n")
    ff90.write("  subroutine lsm_betr_plant_soilbgc_recv(this, bounds, numf, filter, betr_pft, biogeo_fluxes)\n")
    ff90.write("\n")
    ff90.write("  !DESCRIPTION\n")
    ff90.write("  !return plant nutrient yield\n")
    ff90.write("  !\n")
    ff90.write("  !USES\n")
    ff90.write("  use BeTR_biogeoFluxType, only : betr_biogeo_flux_type\n")
    ff90.write("  use BeTR_PatchType, only : betr_patch_type\n")
    ff90.write("  implicit none\n")
    ff90.write("  ! !ARGUMENTS:\n")
    ff90.write("  class("+app_name+"_plant_soilbgc_type) , intent(inout)    :: this\n")
    ff90.write("  type(bounds_type)                  , intent(in)    :: bounds\n")
    ff90.write("  integer                            , intent(in)    :: numf\n")
    ff90.write("  integer                            , intent(in)    :: filter(:)\n")
    ff90.write("  type(betr_patch_type) , intent(in) :: betr_pft\n")
    ff90.write("  type(betr_biogeo_flux_type)        , intent(inout) :: biogeo_fluxes\n")
    ff90.write("\n")
    ff90.write("  ! remove compiler warnings for unused dummy args\n")
    ff90.write("  if (this%dummy_compiler_warning)        continue\n")
    ff90.write("  if (bounds%begc > 0)                    continue\n")
    ff90.write("  if (numf > 0)                           continue\n")
    ff90.write("  if (size(filter) > 0)                   continue\n")
    ff90.write("  if (size(biogeo_fluxes%qflx_adv_col)>0) continue\n")
    ff90.write("  end subroutine lsm_betr_plant_soilbgc_recv\n")
    ff90.write("!----------------------------------------------------------------------\n")
    ff90.write("  subroutine lsm_betr_plant_soilbgc_send(this, bounds, numf, filter,  &\n")
    ff90.write("    betr_pft, biogeo_forc, biogeo_states, biogeo_fluxes)\n")
    ff90.write("  !\n")
    ff90.write("  !DESCRIPTION\n")
    ff90.write("  ! initialize feedback variables for plant soil bgc interactions\n")
    ff90.write("  !\n")
    ff90.write("  !USES\n")
    ff90.write("  use BeTR_biogeoStateType , only : betr_biogeo_state_type\n")
    ff90.write("  use BeTR_biogeoFluxType  , only : betr_biogeo_flux_type\n")
    ff90.write("  use BeTR_decompMod       , only : betr_bounds_type\n")
    ff90.write("  use BeTR_biogeophysInputType , only : betr_biogeophys_input_type\n")
    ff90.write("  use BeTR_PatchType, only : betr_patch_type\n")
    ff90.write("  ! !ARGUMENTS:\n")
    ff90.write("  class("+app_name+"_plant_soilbgc_type) , intent(inout) :: this\n")
    ff90.write("  type(betr_bounds_type)             , intent(in) :: bounds\n")
    ff90.write("  integer                            , intent(in) :: numf\n")
    ff90.write("  integer                            , intent(in) :: filter(:)\n")
    ff90.write("  type(betr_patch_type)              , intent(in) :: betr_pft\n")
    ff90.write("  type(betr_biogeophys_input_type), intent(in):: biogeo_forc\n")
    ff90.write("  type(betr_biogeo_state_type)       , intent(in) :: biogeo_states\n")
    ff90.write("  type(betr_biogeo_flux_type)        , intent(in) :: biogeo_fluxes\n")
    ff90.write("\n")
    ff90.write("  ! remove compiler warnings for unused dummy args\n")
    ff90.write("  if (this%dummy_compiler_warning)       continue\n")
    ff90.write("  if (bounds%begc > 0)                   continue\n")
    ff90.write("  if (numf > 0)                          continue\n")
    ff90.write("  if (size(filter) > 0)                  continue\n")
    ff90.write("  if (size(biogeo_states%zwts_col)>0)    continue\n")
    ff90.write("  if(size(biogeo_fluxes%qflx_adv_col)>0) continue\n")
    ff90.write("\n")
    ff90.write("  end subroutine lsm_betr_plant_soilbgc_send\n")
    ff90.write("end module "+app_name+"PlantSoilBGCType\n")
    ff90.close()
